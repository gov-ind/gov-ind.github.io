(this.webpackJsonptest=this.webpackJsonptest||[]).push([[0],{404:function(A,e,n){},412:function(A,e,n){"use strict";n.r(e),n.d(e,"data",(function(){return Z})),n.d(e,"getTitle",(function(){return Y}));var t=n(6),i=n(7),s=n(9),r=n(8),c=n(53),a=n(1),I=n.n(a),d=n(39),o=n.n(d),g=n(28),h=n(5),l=(n(93),n(0)),C=-1,Q=function(A){Object(s.a)(n,A);var e=Object(r.a)(n);function n(){var A;Object(t.a)(this,n);for(var i=arguments.length,s=new Array(i),r=0;r<i;r++)s[r]=arguments[r];return(A=e.call.apply(e,[this].concat(s))).state={hidden:!1},A}return Object(i.a)(n,[{key:"componentDidMount",value:function(){window.addEventListener("scroll",this.handleScroll.bind(this),!0)}},{key:"componentWillUnmount",value:function(){window.removeEventListener("scroll",this.handleScroll.bind(this),!0)}},{key:"handleScroll",value:function(A){var e=A.target.scrollTop;-1==C||(e>C?(console.log("down"),this.state.hidden||this.setState({hidden:!0})):(console.log("up"),this.state.hidden&&this.setState({hidden:!1}))),C=e}},{key:"scrollDown",value:function(){console.log("down")}},{key:"scrollUp",value:function(){console.log("up")}},{key:"render",value:function(){return Object(l.jsxs)("div",{class:"header"+(this.state.hidden?" header-hidden":""),onClick:this.props.onClick,children:[Object(l.jsxs)("a",{className:"center left white",children:[Y({target:window.location})," "]}),Object(l.jsx)("div",{children:"\xa0"})]})}}]),n}(a.Component),E=n(3),j=n.n(E),b=n(26),f=n.n(b),B=(a.Component,a.Component,n(88)),x=n(416),u=n(417);x.a["hljs-comment"].color="#81A1C1";var k={backgroundColor:"#3b4d61",padding:"2em",borderRadius:"5px",marginTop:"2em",marginBottom:"2em"},p=function(A){return Object(l.jsx)(u.a,Object(B.a)({language:"python",style:x.a,customStyle:k},A))},v=n(86),O=n.n(v),m="s \\equiv (h - xr)k^{-1}",P="(h - zq)k^{-1}",G="k = \\frac{p - 3}{2}",w="g^\\frac{p - 1}{2} \\equiv -1 \\pmod p",R="\\mathbb{Z}_p",M=function(A){Object(s.a)(n,A);var e=Object(r.a)(n);function n(A){var i;return Object(t.a)(this,n),(i=e.call(this,A)).myRef=I.a.createRef(),i}return Object(i.a)(n,[{key:"componentDidMount",value:function(){O.a.render(this.props.children,this.myRef.current,{throwOnError:!1})}},{key:"render",value:function(){return Object(l.jsx)("span",{ref:this.myRef})}}]),n}(a.Component),N=function(A){Object(s.a)(n,A);var e=Object(r.a)(n);function n(){return Object(t.a)(this,n),e.apply(this,arguments)}return Object(i.a)(n,[{key:"render",value:function(){return Object(l.jsx)("div",{className:"main",children:Object(l.jsxs)("div",{className:"content",children:[Object(l.jsxs)("div",{children:[Object(l.jsx)("b",{children:"Description."})," We're given a textbook ElGamal signature scheme with seemingly no implementation mistakes."]}),Object(l.jsx)(p,{children:'from Crypto.Util.number import  inverse, isPrime\nfrom random import SystemRandom\nfrom hashlib import sha256\nfrom flag import FLAG\nimport os\n\nrand = SystemRandom()\n\nclass ElGamal:\n\tdef __init__(self):\n\t\tself.q = 89666094075799358333912553751544914665545515386283824011992558231120286657213785559151513056027280869020616111209289142073255564770995469726364925295894316484503027288982119436576308594740674437582226015660087863550818792499346330713413631956572604302171842281106323020998625124370502577704273068156073608681\n\t\tassert(isPrime(self.q))\n\t\tself.p = 2*self.q + 1\n\t\tassert(isPrime(self.p))\n\t\tself.g = 2\n\t\tself.H = sha256\n\t\tself.x = rand.randint(1,self.p-2)\n\t\tself.y = pow(self.g,self.x,self.p)\n\n\tdef sign(self,m):\n\t\tk = rand.randint(2,self.p-2)\n\t\twhile GCD(k,self.p-1) != 1:\n\t\t\tk = rand.randint(2,self.p-2)\n\t\tr = pow(self.g,k,self.p)\n\t\th = int(self.H(m).hexdigest(),16)\n\t\ts = ((h - self.x * r)* inverse(k,self.p-1)) % (self.p - 1)\n\t\tassert(s != 0)\n\t\treturn (r,s)\n\n\tdef verify(self,m,r,s):\n\t\tif r <= 0 or r >= (self.p):\n\t\t\treturn False\n\t\tif s <= 0 or s >= (self.p-1):\n\t\t\treturn False\n\t\th = int(self.H(m).hexdigest(),16)\n\t\treturn pow(self.g,h,self.p) == (pow(self.y,r,self.p) * pow(r,s,self.p)) % self.p\n\n\n\nif __name__ == \'__main__\':\n\tS = ElGamal()\n\n\tprint("Here are your parameters:\n - generator g: {:d}\n - prime p: {:d}\n - public key y: {:d}\n".format(S.g, S.p, S.y))\n\t\n\tmessage = os.urandom(16)\n\n\tprint("If you can sign this message : {:s}, I\'ll reward you with a flag!".format(message.hex()))\n\n\tr = int(input("r: "))\n\ts = int(input("s: "))\n\tif S.verify(message,r,s):\n\t\tprint(FLAG)\n\telse:\n\t\tprint("Nope.")'}),Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Solution. "}),"Recall that an ElGamal signature on the hash ",Object(l.jsx)(M,{children:"h"})," of a message ",Object(l.jsx)(M,{children:"m"})," consists of the two numbers ",Object(l.jsx)(M,{children:"r"})," and ",Object(l.jsx)(M,{children:"s"})," as defined below."]}),Object(l.jsx)("div",{className:"center-eq",children:Object(l.jsx)(M,{children:"\\begin{aligned}\nr &= g^k \\pmod p \\\\\ns &= (h - xr)k^{-1} \\pmod{p - 1} \\end{aligned}"})}),Object(l.jsxs)("div",{className:"space",children:["Here ",Object(l.jsx)(M,{children:"g"})," and ",Object(l.jsx)(M,{children:"p"})," are public parameters, ",Object(l.jsx)(M,{children:"x"})," is a number such that ",Object(l.jsx)(M,{children:"y = g^x \\pmod p"})," (and ",Object(l.jsx)(M,{children:"y"})," is known), and ",Object(l.jsx)(M,{children:"k"})," is secret. Given ",Object(l.jsx)(M,{children:"y"}),", it is ",Object(l.jsx)("a",{href:"https://en.wikipedia.org/wiki/Discrete_logarithm",children:"believed to be hard"})," to retrieve ",Object(l.jsx)(M,{children:"x"}),", and with out ",Object(l.jsx)(M,{children:"x"})," it is hard to forge a value of ",Object(l.jsx)(M,{children:"s"})," and ",Object(l.jsx)(M,{children:"r"}),"."]}),Object(l.jsxs)("div",{className:"space",children:["As it turns out, there is a ",Object(l.jsx)("a",{href:"",children:"paper"})," that shows that it is easy to forge signatures if the generator ",Object(l.jsx)(M,{children:"g"})," is weak. In this writeup, I basically reformulate page 3 of that paper. I found the corollary the most natural place to start, so let's consider what happens when ",Object(l.jsx)(M,{children:"k = \\frac{(p - 3)}{2}"}),"."]}),Object(l.jsx)("div",{className:"center-eq",children:Object(l.jsx)(M,{children:"\\begin{aligned}\nr &\\equiv g^k \\pmod p \\\\\n  &\\equiv g^{\\frac{p - 3}{2}} \\pmod p \\\\\n  &\\equiv g^{\\frac{p - 1}{2}}g^{-1} \\pmod p \\\\\n  &\\equiv (p - 1) g^{-1} \\pmod p \\\\\n  &\\equiv \\frac{p - 1}{g} \\pmod p \\\\\n  &\\equiv q \\pmod p\n\\end{aligned}"})}),Object(l.jsxs)("div",{children:["It wasn't obvious to me how ",Object(l.jsx)(M,{children:"g^{\\frac{p - 1}{2}}"})," reduced to ",Object(l.jsx)(M,{children:"(p - 1) \\pmod p"})," in the fourth equation, so I've explained that in the ",Object(l.jsx)("a",{href:"#appendix",children:"Appendix"}),". Ultimately, the catastrophe is that ",Object(l.jsx)(M,{children:"g"})," ended up in the denominator, and the irony is that ",Object(l.jsx)(M,{children:"g"})," is 2 in our case and ",Object(l.jsx)(M,{children:"\\frac{p - 1}{g} = \\frac{p - 1}{2} = q"})," because ",Object(l.jsx)(M,{children:"p"}),' is a "safe prime"! So what happens when ',Object(l.jsx)(M,{children:"r = q"}),"? Let's see recall how verification happens."]}),Object(l.jsx)("div",{className:"center-eq",children:Object(l.jsx)(M,{children:"\\begin{aligned}\ng^h &\\equiv r^sy^r \\pmod p \\\\\n    &\\equiv g^{k(h - xr)k^{-1}}g^{xr} \\pmod p \\\\\n    &\\equiv g^{h - xr}g^{xr} \\pmod p\n\\end{aligned}"})}),Object(l.jsxs)("div",{children:["We do not know ",Object(l.jsx)(M,{children:"x"}),", so we cannot calculate ",Object(l.jsx)(M,{children:"g^{h - xr}"}),". But when ",Object(l.jsx)(M,{children:"r = q"}),", ",Object(l.jsx)(M,{children:"g^{xr} \\equiv g^{xq} \\equiv (g^q)^x \\equiv g^{\\frac{p - 1}{2}} \\equiv -1^x"}),", and so, depending on whether ",Object(l.jsx)(M,{children:"x"})," is odd or even, it can take only one of two values (",Object(l.jsx)(M,{children:"\\pm 1"}),"). In either case, the bottom line is that we no longer need ",Object(l.jsx)(M,{children:"x"})," to calculate ",Object(l.jsx)(M,{children:"S"}),": We can just replace ",Object(l.jsx)(M,{children:m})," with ",Object(l.jsx)(M,{children:P})," and the values wouldn't differ. The multiplier ",Object(l.jsx)(M,{children:"z"})," depends on the LSB of ",Object(l.jsx)(M,{children:"x"})," and we'll get to that later, but for now let's focus on calculating the other variable, ",Object(l.jsx)(M,{children:"k^{-1} \\pmod {p -1}"}),"."]}),Object(l.jsxs)("div",{className:"space",children:["First, note that ",Object(l.jsx)(M,{children:"p \\equiv 3 \\pmod 4"}),", so ",Object(l.jsx)(M,{children:G})," is even just like ",Object(l.jsx)(M,{children:"p - 1"}),". This means that ",Object(l.jsx)(M,{children:"k"})," and ",Object(l.jsx)(M,{children:"p - 1"})," are not coprime, and thus ",Object(l.jsx)(M,{children:"k"})," is not invertible. However, if the GCD of ",Object(l.jsx)(M,{children:"k"})," and ",Object(l.jsx)(M,{children:"p - 1"})," is ",Object(l.jsx)(M,{children:"f"}),", then there exists some ",Object(l.jsx)(M,{children:"k_{1}^{-1}"})," such that ",Object(l.jsx)(M,{children:"kk_{1}^{-1} \\equiv f \\pmod {p - 1}"}),". Now, if ",Object(l.jsx)(M,{children:"s \\equiv (h - zq) \\pmod {p - 1}"})," the the ",Object(l.jsx)(M,{children:"r^s"})," part will be calculated as follows."]}),Object(l.jsx)("div",{className:"center-eq",children:Object(l.jsx)(M,{children:"\\begin{aligned}\nr^s &\\equiv g^{k(h - zq)k^{-1}} \\pmod {p - 1} \\\\\n    &\\equiv g^{{kk^{-1}}(h - zq)} \\pmod {p - 1} \\\\\n    &\\equiv g^{f(h - zq)} \\pmod {p - 1}\n\\end{aligned}"})}),Object(l.jsxs)("div",{children:["As you can see, that ",Object(l.jsx)(M,{children:"f"})," is going to mess things up. So all we need to do, then, is to divide ",Object(l.jsx)(M,{children:"(h - zq)"})," by ",Object(l.jsx)(M,{children:"f"})," and our forgery will be complete. However, the crucial thing is that ",Object(l.jsx)(M,{children:"(h - zq)"})," ",Object(l.jsx)("i",{children:"must"})," be divisible by ",Object(l.jsx)(M,{children:"f"})," to remain an integer. But because ",Object(l.jsx)(M,{children:"p = 3 \\pmod 4"}),", the GCD ",Object(l.jsx)(M,{children:"f"})," is 2 (",Object(l.jsx)("a",{href:"appendix2",children:"Why?"}),"), which means that ",Object(l.jsx)(M,{children:"(h - zq)"})," will be divisible!"]}),Object(l.jsxs)("div",{className:"space",children:["So now the only thing left to find is that ",Object(l.jsx)(M,{children:"z"}),". Earlier I mentioned that we can safely replace ",Object(l.jsx)(M,{children:m})," with ",Object(l.jsx)(M,{children:P}),", and depending on the LSB of ",Object(l.jsx)(M,{children:"x"}),", ",Object(l.jsx)(M,{children:"g^{xr} \\equiv g^{xq} \\equiv ({g^q})^x \\equiv \\pm 1 \\pmod p"}),". But our forged value ",Object(l.jsx)(M,{children:"g^q \\pmod p"}),", on the hand, is always -1. So if the actual ",Object(l.jsx)(M,{children:"y^{q} \\equiv g^{xq} \\equiv 1 \\pmod p"})," were 1, we set ",Object(l.jsx)(M,{children:"z = 2"})," so that ",Object(l.jsx)(M,{children:"g^{zq} \\equiv ({g^q})^z \\equiv -1^z \\equiv -1^2 \\equiv 1 \\pmod p"}),", for example. Apologies for labouring the point, but it took me quite a while to understand this part. Anyways, if you plug all of that into code, you get the flag."]}),Object(l.jsx)(p,{children:"from hashlib import sha256\nfrom math import gcd\nfrom pwn import remote, process\n\ndebug = False\n\nwhile True:\n    if debug:\n        p1 = process(['python3.8', 'server.py'])\n    else:\n        p1 = remote('remote1.thcon.party', 11002)\n\n    p1.recvline()\n\n    g = int(p1.recvline().split(b': ')[1].strip())\n    p = int(p1.recvline().split(b': ')[1].strip())\n    y = int(p1.recvline().split(b': ')[1].strip())\n\n    p1.recvline()\n\n    message = bytes.fromhex(p1.recvline().split(b': ')[1].split(b',')[0].decode())\n\n    q = (p - 1) // 2\n    k = (p - 3) // 2\n\n    if pow(y, q, p) == 1:\n        z = 2\n    else:\n        z = 1\n\n    h2 = int(sha256(message).hexdigest(), 16) - q * z\n    f = gcd(k, p - 1)\n\n    k_i = pow(k // f, -1 , (p - 1) // f)\n\n    if h2 % f == 0:\n        s = (h2 // f) * k_i % ((p - 1) // f)\n        r = pow(g, k, p)\n\n        p1.sendline(f'{r}')\n        p1.sendline(f'{s}')\n\n        vv = p1.recvline()\n        print(vv.split(b\"b'\")[-1][:-2].strip())\n\n        break"}),Object(l.jsxs)("div",{id:"appendix",children:[Object(l.jsx)("b",{children:"Appendix. "}),"Why is ",Object(l.jsx)(M,{children:w}),"? First, Recall that if ",Object(l.jsx)(M,{children:"g"})," is the generator of ",Object(l.jsx)(M,{children:R})," (the ring of integers modulo ",Object(l.jsx)(M,{children:"p"}),"), this means that ",Object(l.jsx)(M,{children:"g"})," generates every element in ",Object(l.jsx)(M,{children:R}),". In other words, its order is ",Object(l.jsx)(M,{children:"p - 1"})," (because it has ",Object(l.jsx)(M,{children:"p - 1"})," elements), and equivalently, ",Object(l.jsx)(M,{children:"p - 1"})," is the smallest number such that ",Object(l.jsx)(M,{children:"g^{p - 1} \\equiv 1 \\pmod p"}),"."]}),Object(l.jsxs)("div",{className:"space",children:["Now, by Euler's criterion, ",Object(l.jsx)(M,{children:w})," can take only one of two values (",Object(l.jsx)(M,{children:"\\pm 1"}),"). If it were ",Object(l.jsx)(M,{children:"1"}),", then this implies that ",Object(l.jsx)(M,{children:"\\frac{p - 1}{2}"}),", and not ",Object(l.jsx)(M,{children:"p - 1"})," is the order of the group. But then this would mean that the group's order is less than ",Object(l.jsx)(M,{children:"p - 1"}),", implying that ",Object(l.jsx)(M,{children:"g"})," didn't generate all the elements of the group, thus contradicting our assumption about ",Object(l.jsx)(M,{children:"g"}),". Thus the only value ",Object(l.jsx)(M,{children:"g^{\\frac{p - 1}{2}} \\pmod p"})," can take is ",Object(l.jsx)(M,{children:"-1"}),"."]}),Object(l.jsxs)("div",{id:"appendix2",class:"space",children:["Why is 2 the GCD of ",Object(l.jsx)(M,{children:"p - 1"})," and ",Object(l.jsx)(M,{children:G})," when ",Object(l.jsx)(M,{children:"p \\equiv 3 \\pmod 4"}),"? ",Object(l.jsx)(M,{children:"p \\equiv 3 \\pmod 4"})," implies that we have some ",Object(l.jsx)(M,{children:"k_1"})," and ",Object(l.jsx)(M,{children:"k2"})," such that:"]}),Object(l.jsx)("div",{className:"center-eq",children:Object(l.jsx)(M,{children:"\\begin{aligned}\np &= 4y_1 + 3 \\\\\n\\implies p - 1 &= 4y_1 + 2 \\\\\nk &= \\frac{p - 3}{2} \\\\\n  &= \\frac{4y_1}{2} \\\\\n  &= 2y_1\n\\end{aligned}"})}),Object(l.jsxs)("div",{children:["So, the GCD of ",Object(l.jsx)(M,{children:"p - 1"}),", ",Object(l.jsx)(M,{children:G})," ",Object(l.jsx)(M,{children:"="})," GCD of ",Object(l.jsx)(M,{children:"4y_1 + 2, 2y_1"})," ",Object(l.jsx)(M,{children:"="})," GCD of ",Object(l.jsx)(M,{children:"2(2y_1 + 1), 2y_1"}),". 2 divides both those numbers, so it only remains to prove that ",Object(l.jsx)(M,{children:"2y_1 + 1"})," and ",Object(l.jsx)(M,{children:"y_1"})," are coprime. We can prove this by contradiction: If we assume that these numbers had a common factor ",Object(l.jsx)(M,{children:"X > 1"}),", then there exits some ",Object(l.jsx)(M,{children:"z_1"})," and ",Object(l.jsx)(M,{children:"z_2"})," such that:"]}),Object(l.jsx)("div",{className:"center-eq",children:Object(l.jsx)(M,{children:"\\begin{aligned}\nz_2X &= y_1 \\\\\n\\implies 2z_2X &= 2y_1 \\\\\nz_1X &= 2y_1 + 1 \\\\\n\\implies (z_1 - 2z_2)X &= 1\n\\end{aligned}"})}),Object(l.jsx)("div",{className:"space",children:"Clearly, the last equation cannot be true as the product of two numbers greater than 1 cannot be 1. Hence, our assumption is wrong and 2 is the only (and thus, greatest) factor."})]})})}}]),n}(a.Component),D=(n(43),function(A){Object(s.a)(n,A);var e=Object(r.a)(n);function n(){return Object(t.a)(this,n),e.apply(this,arguments)}return Object(i.a)(n,[{key:"render",value:function(){return Object(l.jsx)("div",{className:"main",children:Object(l.jsxs)("div",{className:"content",children:[Object(l.jsxs)("div",{children:[Object(l.jsx)("b",{children:"Description. "}),"Given one big ",Object(l.jsx)(j.a,{children:"$L$ x $W$ rectangle and $k$"})," smaller rectangles, our task is to cut the big rectangle into portions, such that each portion's dimension is equal to one of the ",Object(l.jsx)(j.a,{children:"$k$"})," smaller rectangle's dimensions, and return the minimum wasted space. Also note that each of the ",Object(l.jsx)(j.a,{children:"$k$"})," smaller rectangles may be used more than once, or not even once. Here's an example from the challenge description.",Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Sample Input:"}),Object(l.jsx)("br",{}),"5 5 3 ",Object(l.jsx)("br",{}),"4 2 ",Object(l.jsx)("br",{}),"3 1 ",Object(l.jsx)("br",{}),"4 1 ",Object(l.jsx)("br",{})]}),Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Sample Output:"}),Object(l.jsx)("br",{}),"5"]}),Object(l.jsx)("div",{className:"space",children:Object(l.jsx)("b",{children:"Explanation:"})}),"We\u2019re given a 5x5 grid, with three different bar types.The dimensions are 4x2, 3x1, and 4x1. We can depict the grid as follows, with each color representing a different bar. Blue bars are 4x1, red bars are 4x2, and white squares are wasted. Note that bars can be used multiple times, in the case of 4x2. Some bars, such as 3x1 bars, may also be unused. 5 squares are wasted at minimum.",Object(l.jsx)("br",{}),Object(l.jsx)("img",{src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAYAAAA10dzkAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/Z1A+gAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAZt0lEQVR4nO3db2yVhdn48astaXFacCgghKIQI/4LGFBJH5zxD2rQEN0rQyAy4m8vTDWSxmTriwqNW0qyxGgiY2TZxgtHcDNBE/MoYSzA3CACTX8Bg8Y/XYbjn5qMA808NbS/F2ifMXny08m5bz3X55M05T6c9r5ypaFf7nPa0zAyMjISAACk0Vj2AAAAFEsAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJDMmLIH+DYbHh6Ow4cPR2trazQ0NJQ9DgDwJYyMjMTJkydj6tSp0diY81qYAPwaDh8+HG1tbWWPAQD8Bw4dOhTTpk0re4xSCMCvobW1NSLOfAGNGzeu5GkAgC+jUqlEW1vb6PfxjATg1/D5w77jxo0TgADwLZP56Vs5H/gGAEhMAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEgmdQCuXr06Ghoaznq7+uqryx4LAKCm0r8U3HXXXRd/+MMfRo/HjEm/EgCgzqWvnTFjxsRll11W9hgAAIVJH4DvvPNOTJ06NcaOHRvt7e3R29sb06dPP+d9q9VqVKvV0eNKpVLT2Xbt2hXvv/9+Tc9BxNDQUDQ3N5c9Rt2z52LYczHsuRgzZ86M9vb2sseoSw0jIyMjZQ9RlldffTVOnToVs2bNiiNHjkRPT0/8/e9/jwMHDkRra+sX7r969ero6en5wu0nTpyIcePGndfZdu3aFd/7r/+K0+f1s3IujRExXPYQCdhzMey5GI2NjTE8bNO11tTUFH/605/OewRWKpUYP358Tb5/f1ukDsB/949//CMuv/zyePrpp+Phhx/+wt+f6wpgW1tbTb6Afvvb38ayZcvi+Yi45rx+Zv7Vf0dEd4Q915g9F8OeizG65+efj2uuselaOXjw4Jnvg88/H0uXLj2vn1sAegj4LBdffHFcddVV8e67757z71taWqKlpaXQma6JiLmFnjGXg5+9t+fasudi2HMxRvd8zTUxd65N8+2U+tfA/LtTp07Fe++9F1OmTCl7FACAmkkdgE888UTs2LEj/vrXv8Zf/vKX+P73vx9NTU2xZMmSskcDAKiZ1A8Bf/DBB7FkyZL4+OOPY+LEiXHLLbfE7t27Y+LEiWWPBgBQM6kDcNOmTWWPAABQuNQPAQMAZCQAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAH5mzZo10dDQECtXrix7FACAmhKAEbFnz55Yv359zJ49u+xRAABqLn0Anjp1KpYuXRq//OUv47vf/W7Z4wAA1Fz6AOzo6Ij77rsvFi5cWPYoAACFGFP2AGXatGlT9PX1xZ49e77U/avValSr1dHjSqVSq9FG/XdEHKz5WfL682fv7bm27LkY9lyMz/d88KAt15L91lbaADx06FA8/vjjsXXr1hg7duyX+pje3t7o6emp8WRnHDlyJCIaozuGCzlfbvZcDHsuhj0XozGWLVtW9hB1r7GxMYaGhsoeoy6lDcB9+/bF8ePHY+7cuaO3nT59Onbu3BnPPfdcVKvVaGpqOutjurq6orOzc/S4UqlEW1tbTeb75JNPImI4Ip6PiGtqcg4izlwr6Q57rjV7LoY9F+NgRCyLRx55JBYsWFD2MHVrYGAguru7o7m5uexR6lLaALzzzjtj//79Z922YsWKuPrqq+NHP/rRF+IvIqKlpSVaWlqKGvEz10TE3P/vvfhPff4Qgz3Xlj0Xw56LtGDBgli6dGnZY9Stvr6+6O7uLnuMupU2AFtbW+P6668/67YLL7wwLrnkki/cDgBQT9L/FDAAQDZprwCey/bt28seAQCg5lwBBABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkEzqAFy3bl3Mnj07xo0bF+PGjYv29vZ49dVXyx4LAKCmUgfgtGnTYs2aNbFv377Yu3dv3HHHHXH//ffHm2++WfZoAAA1M6bsAcq0ePHis45/+tOfxrp162L37t1x3XXXlTQVAEBtpQ7Af3X69On4/e9/H4ODg9He3l72OAAANZM+APfv3x/t7e3xySefxEUXXRSbN2+Oa6+99pz3rVarUa1WR48rlUoBEx4s4ByZDXz23p5ry56LYc/FOLPfgYGB6OvrK3mW+nXwoK/jWkofgLNmzYr+/v44ceJEvPjii7F8+fLYsWPHOSOwt7c3enp6Cpnrn//8Z5x5iuayQs6Xmz0Xw56LYc/FaIzu7u7o7u4ue5C61tjYGENDQ2WPUZfSB2Bzc3NceeWVERExb9682LNnTzz77LOxfv36L9y3q6srOjs7R48rlUq0tbXVZK4LLrggIoYj4qmImFGTcxAR8eeIWBf2XGv2XAx7LsZARHTHI488EgsWLCh7mLo1MDAQ3d3d0dzcXPYodSl9AP674eHhsx7m/VctLS3R0tJS8ET3RsTcgs+Zzbqw5yLYczHsufb6IqI7FixYEEuXLi17mLrV19fnCmsNpQ7Arq6uWLRoUUyfPj1OnjwZGzdujO3bt8eWLVvKHg0AoGZSB+Dx48fjoYceiiNHjsT48eNj9uzZsWXLlrjrrrvKHg0AoGZSB+CvfvWrskcAAChc6lcCAQDISAACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIJnUA9vb2xk033RStra0xadKkeOCBB+Ltt98ueywAgJpKHYA7duyIjo6O2L17d2zdujU+/fTTuPvuu2NwcLDs0QAAamZM2QOU6bXXXjvreMOGDTFp0qTYt29f3HrrrSVNBQBQW6kD8N+dOHEiIiImTJhwzr+vVqtRrVZHjyuVSgFTHSzgHJkNfPbenmvLnothz8U4s9+BgYHo6+sreZb6dfCgr+NaEoCfGR4ejpUrV8aCBQvi+uuvP+d9ent7o6enp5B5xo4dG2ceoV9WyPlys+di2HMx7LkYjdHd3R3d3d1lD1LXGhsbY2hoqOwx6pIA/ExHR0ccOHAgXn/99f/1Pl1dXdHZ2Tl6XKlUoq2trSbzTJkyJSKG45GImFqTMxAR8X8j4kV7rjl7LoY9F+PzPT/11FMxY8aMssepWwMDA9Hd3R3Nzc1lj1KXBGBEPProo/HKK6/Ezp07Y9q0af/r/VpaWqKlpaXAySL+T0TMLfSMufw2Il4Me641ey6GPRfj8z3fe++9MXeuTddKX1+fK6w1lDoAR0ZG4rHHHovNmzfH9u3b/U8OAEghdQB2dHTExo0b4+WXX47W1tY4evRoRESMHz8+LrjggpKnAwCojdS/B3DdunVx4sSJuO2222LKlCmjby+88ELZowEA1EzqK4AjIyNljwAAULjUVwABADISgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkkzoAd+7cGYsXL46pU6dGQ0NDvPTSS2WPBABQc6kDcHBwMObMmRNr164texQAgMKMKXuAMi1atCgWLVpU9hgAAIVKHYBfVbVajWq1OnpcqVRqfs6DNT9DbgOfvbfn2rLnYthzMUb3fNCma8l+a0sAfgW9vb3R09NTyLmGhoaiMSKWFXK23Oy5GPZcDHsuRmNjYyxbZtO11tjYGENDQ2WPUZcE4FfQ1dUVnZ2do8eVSiXa2tpqcq7m5uYYjoinImJGTc5ARMSfI2Jd2HOt2XMx7LkYf46IdcPD8dRTT8WMGTZdKwMDA9Hd3R3Nzc1lj1KXBOBX0NLSEi0tLYWe896ImFvoGfNZF/ZcBHsuhj0XY11E3HvvvTF3rk3XSl9fX3R3d5c9Rt1K/VPAAAAZpb4CeOrUqXj33XdHjwcGBqK/vz8mTJgQ06dPL3EyAIDaSR2Ae/fujdtvv330+PPn9y1fvjw2bNhQ0lQAALWVOgBvu+22GBkZKXsMAIBCeQ4gAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZNIH4Nq1a+OKK66IsWPHxvz58+ONN94oeyQAgJpKHYAvvPBCdHZ2xqpVq6Kvry/mzJkT99xzTxw/frzs0QAAaiZ1AD799NPxwx/+MFasWBHXXntt/OIXv4jvfOc78etf/7rs0QAAamZM2QOUZWhoKPbt2xddXV2jtzU2NsbChQtj165d5/yYarUa1Wp19LhSqdR8zoM1P0NuA5+9t+fasudi2HMxRvd80KZryX5rK20AfvTRR3H69OmYPHnyWbdPnjw53nrrrXN+TG9vb/T09BQxXsycOTOaImJZIWfLrTHsuQj2XAx7LkZjY2MsW2bTtdbU1BQzZ84se4y6lDYA/xNdXV3R2dk5elypVKKtra0m52pvb48//eUv8f7779fk8/M/hoaGorm5uewx6p49F8Oei2HPxZg5c2a0t7eXPUZdShuAl156aTQ1NcWxY8fOuv3YsWNx2WWXnfNjWlpaoqWlpYjxIuJMBPrCBwDOt7Q/BNLc3Bzz5s2Lbdu2jd42PDwc27ZtE10AQF1LewUwIqKzszOWL18eN954Y9x8883xzDPPxODgYKxYsaLs0QAAaiZ1AD744IPx4YcfxpNPPhlHjx6NG264IV577bUv/GAIAEA9aRgZGRkpe4hvq0qlEuPHj48TJ07EuHHjyh4HAPgSfP9O/BxAAICsBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkUr8U3Nf1+YuoVCqVkicBAL6sz79vZ34xNAH4NZw8eTIiItra2kqeBAD4qk6ePBnjx48ve4xSeC3gr2F4eDgOHz4cra2t0dDQcF4/d6VSiba2tjh06FDa1yksgj0Xw56LYc/FsOdi1HLPIyMjcfLkyZg6dWo0NuZ8NpwrgF9DY2NjTJs2rabnGDdunH9gCmDPxbDnYthzMey5GLXac9Yrf5/Lmb0AAIkJQACAZATgN1RLS0usWrUqWlpayh6lrtlzMey5GPZcDHsuhj3Xlh8CAQBIxhVAAIBkBCAAQDICEAAgGQEIAJCMAPwGWrt2bVxxxRUxduzYmD9/frzxxhtlj1R3du7cGYsXL46pU6dGQ0NDvPTSS2WPVJd6e3vjpptuitbW1pg0aVI88MAD8fbbb5c9Vt1Zt25dzJ49e/QX5ra3t8err75a9lh1b82aNdHQ0BArV64se5S6snr16mhoaDjr7eqrry57rLojAL9hXnjhhejs7IxVq1ZFX19fzJkzJ+655544fvx42aPVlcHBwZgzZ06sXbu27FHq2o4dO6KjoyN2794dW7dujU8//TTuvvvuGBwcLHu0ujJt2rRYs2ZN7Nu3L/bu3Rt33HFH3H///fHmm2+WPVrd2rNnT6xfvz5mz55d9ih16brrrosjR46Mvr3++utlj1R3/BqYb5j58+fHTTfdFM8991xEnHm94ba2tnjsscfixz/+ccnT1aeGhobYvHlzPPDAA2WPUvc+/PDDmDRpUuzYsSNuvfXWssepaxMmTIif/exn8fDDD5c9St05depUzJ07N37+85/HT37yk7jhhhvimWeeKXusurF69ep46aWXor+/v+xR6porgN8gQ0NDsW/fvli4cOHobY2NjbFw4cLYtWtXiZPB+XHixImIOBMn1Mbp06dj06ZNMTg4GO3t7WWPU5c6OjrivvvuO+vfas6vd955J6ZOnRozZ86MpUuXxt/+9reyR6o7Y8oegP/x0UcfxenTp2Py5Mln3T558uR46623SpoKzo/h4eFYuXJlLFiwIK6//vqyx6k7+/fvj/b29vjkk0/ioosuis2bN8e1115b9lh1Z9OmTdHX1xd79uwpe5S6NX/+/NiwYUPMmjUrjhw5Ej09PfG9730vDhw4EK2trWWPVzcEIFCIjo6OOHDggOfy1MisWbOiv78/Tpw4ES+++GIsX748duzYIQLPo0OHDsXjjz8eW7dujbFjx5Y9Tt1atGjR6J9nz54d8+fPj8svvzx+97vfeUrDeSQAv0EuvfTSaGpqimPHjp11+7Fjx+Kyyy4raSr4+h599NF45ZVXYufOnTFt2rSyx6lLzc3NceWVV0ZExLx582LPnj3x7LPPxvr160uerH7s27cvjh8/HnPnzh297fTp07Fz58547rnnolqtRlNTU4kT1qeLL744rrrqqnj33XfLHqWueA7gN0hzc3PMmzcvtm3bNnrb8PBwbNu2zXN5+FYaGRmJRx99NDZv3hx//OMfY8aMGWWPlMbw8HBUq9Wyx6grd955Z+zfvz/6+/tH32688cZYunRp9Pf3i78aOXXqVLz33nsxZcqUskepK64AfsN0dnbG8uXL48Ybb4ybb745nnnmmRgcHIwVK1aUPVpdOXXq1Fn/mxwYGIj+/v6YMGFCTJ8+vcTJ6ktHR0ds3LgxXn755WhtbY2jR49GRMT48ePjggsuKHm6+tHV1RWLFi2K6dOnx8mTJ2Pjxo2xffv22LJlS9mj1ZXW1tYvPH/1wgsvjEsuucTzWs+jJ554IhYvXhyXX355HD58OFatWhVNTU2xZMmSskerKwLwG+bBBx+MDz/8MJ588sk4evRo3HDDDfHaa6994QdD+Hr27t0bt99+++hxZ2dnREQsX748NmzYUNJU9WfdunUREXHbbbeddftvfvOb+MEPflD8QHXq+PHj8dBDD8WRI0di/PjxMXv27NiyZUvcddddZY8GX9kHH3wQS5YsiY8//jgmTpwYt9xyS+zevTsmTpxY9mh1xe8BBABIxnMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEjm/wFFi11qiOi0cQAAAABJRU5ErkJggg=="})]}),Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Disclaimer. "}),"I misunderstood the problem description, so my solution - while it works - is not the intended one. What I totally missed is that all cuts need to go all the way through, making this a cutting problem (and not a bin packing problem as I initially thought) Nevertheless, the heuristic I describe gives the optimal solution about 80% to 90% of the time, and with ten rounds, it is ",Object(l.jsx)("i",{children:"just"})," barely good enough to get the flag (the chances are about 10%)."]}),Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Analysis. "}),"There are ",Object(l.jsx)("a",{href:"https://www.aaai.org/Papers/ICAPS/2003/ICAPS03-029.pdf",children:"many"})," ",Object(l.jsx)("a",{href:"http://pds25.egloos.com/pds/201504/21/98/RectangleBinPack.pdf",children:"papers"})," ",Object(l.jsx)("a",{href:"https://www.codeproject.com/Articles/210979/Fast-optimizing-rectangle-packing-algorithm-for-bu",children:"describing"})," bin / rectangle packing algorithms, so you can have a look at those for an overview. However, because in this challenge we have the choice of packing each rectangle more than once (or never), I wrote a quick and dirty recursive function loosely based on ",Object(l.jsx)("a",{href:"https://en.wikipedia.org/wiki/Rectangle_packing#Packing_identical_squares_in_a_rectilinear_polygon",children:"this"}),"."]}),Object(l.jsxs)("div",{className:"space",children:["The function as such is pretty simple. It takes as input the big rectangle's dimensions ",Object(l.jsx)(j.a,{children:"$L$ and $W$, and $k$ smaller rectangles"}),", and tries to pack a combination of one or more of these small rectangles such that the either the wasted length or height is minimized. For example, given ",Object(l.jsx)(j.a,{children:"$L = 17$ and $W = 7$, and four rectangles $(5, 7), (3, 11), (7, 3), and (11, 5)$, one naive approach is to just pack three $(5, 7)$"})," rectangles horizontally like this and minimize wasted length."]}),Object(l.jsx)("img",{src:"data:image/png;base64,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vNLn2q6urujs7OxxAQAYbFIH4JQpU2Lx4sXx0EMPxaJFi6K1tTVOP/302Lx5c6/rFyxYEHV1deVLU1PTAE8MAPDBpQ7A5ubmOP/88+Okk06K6dOnx4MPPhibNm2K++67r9f18+bNi46OjvJl/fr1AzwxAMAHl/5nAN9u5MiRccwxx8S6det6vb2mpiZqamoGeCoAgP0r9TuA77Rly5Z48cUXY+zYsZUeBQCg36QOwB/84AexcuXK+Pe//x2PPfZYfOlLX4qDDjooLrrookqPBgDQb1J/C/jVV1+Niy66KDZu3BhHHHFEfPazn43HH388jjjiiEqPBgDQb1IH4D333FPpEQAABlzqbwEDAGQkAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMukDcOHChXHUUUfF8OHDY8qUKfHkk09WeiQAgH6VOgDvvffemDt3bsyfPz9WrVoVkydPjunTp8frr79e6dEAAPpN6gD81a9+Fd/61rfi61//enzsYx+Lm266KQ499NC49dZbKz0aAEC/GVrpASpl+/bt8fTTT8e8efPK1w0ZMiSmTZsWLS0tvd6nq6srurq6yh93dnb2+5wRqwfgz+DA1/q/f9oP7GZP8Ha79sHq1dWzH6rpsRyI0gbgG2+8ETt37oz6+voe19fX18e//vWvXu+zYMGCuO666wZivJg4cWJEHBQRlwzIn8dgMCTsB3qyJ3i7IXHJJdW1Hw499NAYPXp0pceoSmkD8P2YN29ezJ07t/xxZ2dnNDU19cufNXXq1Hjssb/ESy+91C/H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sbHPNdW4H9i7HTt2xFe+8pUoiiIWLVq0x7XV+vy68MILy/9+4oknxkknnRRHH310rFixIs4888wKTlY5t956a1x88cV7/UWwat0T+8o7gANs9OjRcdBBB0V7e3uP69vb26OhoaHX+zQ0NOzT+sHmyiuvjD/+8Y/xyCOPxLhx4/bpvgcffHB84hOfiHXr1vXTdANv5MiRccwxx/T5mKp9P0REvPzyy7Fs2bL45je/uU/3q8b9sPvzui+f8/fzOjNY7I6/l19+OZYuXbrHd/96s7fn12A1ceLEGD16dJ+Pq5r3RETEX/7yl1izZs0+v2ZEVO+e2BsBOMCGDRsWp5xySixfvrx8XXd3dyxfvrzHOxlvN3Xq1B7rIyKWLl3a5/rBoiiKuPLKK+P++++Phx9+OCZMmLDPx9i5c2c8//zzMXbs2H6YsDK2bNkSL774Yp+PqVr3w9vddtttMWbMmDj77LP36X7VuB8mTJgQDQ0NPT7nnZ2d8cQTT/T5OX8/rzODwe74W7t2bSxbtiwOP/zwfT7G3p5fg9Wrr74aGzdu7PNxVeue2O2WW26JU045JSZPnrzP963WPbFXlf4tlIzuueeeoqampli8eHHxz3/+s7j88suLkSNHFm1tbUVRFMVXv/rV4kc/+lF5/d/+9rdi6NChxS9/+cti9erVxfz584uDDz64eP755yv1EPaLK664oqirqytWrFhRvPbaa+XLm2++WV7zznNx3XXXFX/+85+LF198sXj66aeLCy+8sBg+fHjxj3/8oxIPYb/4/ve/X6xYsaJobW0t/va3vxXTpk0rRo8eXbz++utFUeTZD7vt3LmzGD9+fHH11Ve/67Zq3Q+bN28unnnmmeKZZ54pIqL41a9+VTzzzDPl3279+c9/XowcObJ44IEHiueee66YOXNmMWHChOK///1v+RhnnHFGceONN5Y/3tvrzIFoT+dh+/btxRe/+MVi3LhxxbPPPtvjNaOrq6t8jHeeh709vw5UezoXmzdvLn7wgx8ULS0tRWtra7Fs2bLi5JNPLj760Y8W27ZtKx+j2vfEbh0dHcWhhx5aLFq0qNdjVMue2N8EYIXceOONxfjx44thw4YVp556avH444+Xb/u///u/Yvbs2T3W33fffcUxxxxTDBs2rDj++OOLP/3pTwM88f4XEb1ebrvttvKad56Lq666qnze6uvriy984QvFqlWrBn74/eiCCy4oxo4dWwwbNqz48Ic/XFxwwQXFunXryrdn2Q+7/fnPfy4iolizZs27bqvW/fDII4/0+lzY/Vi7u7uLa665pqivry9qamqKM888813n58gjjyzmz5/f47o9vc4ciPZ0HlpbW/t8zXjkkUfKx3jnedjb8+tAtadz8eabbxZnnXVWccQRRxQHH3xwceSRRxbf+ta33hVy1b4ndrv55puLQw45pNi0aVOvx6iWPbG/lYqiKPr1LUYAAA4ofgYQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGT+H8gudLClLWmDAAAAAElFTkSuQmCC"}),Object(l.jsxs)("div",{className:"space",children:["If we were allowed to choose only one rectangle, then this is optimal because the wasted space is 2 (",Object(l.jsx)(j.a,{children:"$17 \\equiv 2 \\pmod 5$"}),"). In fact, because 17 is prime, we'll never find a number ",Object(l.jsx)(j.a,{children:"$n$ such that $17 \\equiv 0 \\pmod n$"}),". However, we can find a combination of numbers that add up to 17. For instance, 5 + 5 + 7 will do, and so will 7 + 7 + 3. So we can optimize this function by fixing a ",Object(l.jsx)(j.a,{children:"$k$ for each small rectangle of length $l$"})," such that ",Object(l.jsx)(j.a,{children:"k = L // l"}),", looping from ",Object(l.jsx)(j.a,{children:"$1$ to $k$, and checking if any other rectangle divides the remainder. In our case, $k = 17 // 5 = 3$, and for $i = 2$, we find that "})," ",Object(l.jsx)(j.a,{children:"$5i + 7 \\equiv 0 \\pmod {17}$"}),". In pictures, we have:"]}),Object(l.jsx)("img",{src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAYAAAA10dzkAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/Z1A+gAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAdGElEQVR4nO3df6zVdf3A8ddB5KLGvYyQe7lxUbBUMqW0JCz7LmXCrRmU5Y9podmPOWwZtYwtJVcb/VprOUL/UNE5NdsSVzkbkGDpVUt0pREDvSkO7jXZ7r2AcWHcz/cP4tjVe8Gr3Hu45/V4bGd6z3mfD6/zue977tNz75FSURRFAACQxohKDwAAwNASgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkM7LSAwxnPT09sWXLlhgzZkyUSqVKjwMAvAlFUcT27dujsbExRozI+VqYAHwbtmzZEk1NTZUeAwB4CzZv3hyTJk2q9BgVIQDfhjFjxkTEvg1UW1tb4WkAgDejq6srmpqayt/HMxKAb8P+H/vW1tYKQAAYZjL/+lbOH3wDACQmAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACRTtQG4ZMmS+NCHPhRjxoyJCRMmxLx582LDhg291uzatSsWLFgQ73znO+Md73hHXHDBBdHe3l6hiQEAhkbVBuDatWtjwYIF8dhjj8XKlStjz549cd5558XOnTvLa77xjW/Eb3/72/j1r38da9eujS1btsRnPvOZCk4NADD4SkVRFJUeYij8+9//jgkTJsTatWvjYx/7WHR2dsaxxx4bd911V3z2s5+NiIh//vOfMW3atGhpaYkPf/jDBz1mV1dX1NXVRWdnZ9TW1g72QwAADgHfv6v4FcDX6+zsjIiIcePGRUTEk08+GXv27IlZs2aV15x88skxefLkaGlp6fMY3d3d0dXV1esCADDcpAjAnp6euOaaa+IjH/lIvO9974uIiLa2thg1alSMHTu219r6+vpoa2vr8zhLliyJurq68qWpqWmwRwcAOORSBOCCBQvimWeeiXvuuedtHWfRokXR2dlZvmzevPkQTQgAMHRGVnqAwXb11VfH7373u3j44Ydj0qRJ5esbGhpi9+7d0dHR0etVwPb29mhoaOjzWDU1NVFTUzPYIwMADKqqfQWwKIq4+uqr47777os//vGPMWXKlF63n3HGGXHkkUfG6tWry9dt2LAhXnzxxZg5c+ZQjwsAMGSq9hXABQsWxF133RX3339/jBkzpvx7fXV1dXHUUUdFXV1dXHnllbFw4cIYN25c1NbWxte+9rWYOXPmm3oHMADAcFW1/xuYUqnU5/W33XZbXH755RGx738E/c1vfjPuvvvu6O7ujtmzZ8cvf/nLfn8E/HreRg4Aw4/v31UcgEPBBgKA4cf37yr+HUAAAPomAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMlUbgA8//HCcf/750djYGKVSKVasWNHr9ssvvzxKpVKvy5w5cyozLADAEKraANy5c2dMnz49li5d2u+aOXPmxNatW8uXu+++ewgnBACojJGVHmCwNDc3R3Nz8wHX1NTURENDwxBNBABweKjaVwDfjDVr1sSECRPipJNOiquuuiq2bdt2wPXd3d3R1dXV6wIAMNykDcA5c+bEHXfcEatXr44f/ehHsXbt2mhubo69e/f2e58lS5ZEXV1d+dLU1DSEEwMAHBqloiiKSg8x2EqlUtx3330xb968ftc8//zzccIJJ8SqVavi3HPP7XNNd3d3dHd3lz/u6uqKpqam6OzsjNra2kM9NgAwCLq6uqKuri719++0rwC+3tSpU2P8+PGxadOmftfU1NREbW1trwsAwHAjAP/rpZdeim3btsXEiRMrPQoAwKCq2ncB79ixo9erea2trfH000/HuHHjYty4cXHDDTfEBRdcEA0NDfHcc8/Ft7/97Xj3u98ds2fPruDUAACDr2oD8K9//Wt8/OMfL3+8cOHCiIiYP39+LFu2LP72t7/F7bffHh0dHdHY2BjnnXdefP/734+amppKjQwAMCRSvAlksPglUgAYfnz/9juAAADpCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkEzVBuDDDz8c559/fjQ2NkapVIoVK1b0ur0oirj++utj4sSJcdRRR8WsWbNi48aNlRkWAGAIVW0A7ty5M6ZPnx5Lly7t8/Yf//jH8Ytf/CJuuummePzxx+OYY46J2bNnx65du4Z4UgCAoTWy0gMMlubm5mhubu7ztqIo4uc//3l897vfjblz50ZExB133BH19fWxYsWKuPjii4dyVACAIVW1rwAeSGtra7S1tcWs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"}),Object(l.jsxs)("div",{className:"space",children:["Because this is the edge case, the function is done and returns the packed items. But wasn't it so convenient that it received a ",Object(l.jsx)(j.a,{children:"$W = 5$"})," equal to one of the smaller rectangle's ",Object(l.jsx)(j.a,{children:"$W$"}),"? To see how this happened, let's consider how we'll invoke the recursive function such that it receives a convenient ",Object(l.jsx)(j.a,{children:"$W$"}),". Consider ",Object(l.jsx)(j.a,{children:"$L = 17, W = 21$"}),": We pick the first rectangle (5, 7), place it in the bottom-left corner, and decide to partition either vertically or horizontally. For a start, let's partition horizontally like this (the grey area is the newly partitioned rectangle)."]}),Object(l.jsx)("img",{src:"data:image/png;base64,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"}),Object(l.jsxs)("div",{className:"space",children:["We now have the ",Object(l.jsx)(j.a,{children:"$L = 17, W = 7$"})," that we want to call the function with, and once we do so, it returns the combination (which we first tested it with)."]}),Object(l.jsx)("img",{src:"data:image/png;base64,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BCAAQDICEAAgGQEIAJCMAAQASEYAAgAkU7UB+NRTT8WVV14ZTU1NUVNTEytXrux1/Q033BA1NTW9TnPmzKnMsAAAZVS1Abh///6YPn16LF26tN81c+bMiV27dpVODz74YBknBACojJGVHmCwtLS0REtLyzHX1NbWRmNjY5kmAgAYGqr2HcC3Yu3atTFhwoQ455xz4qabboo9e/Ycc313d3d0dXX1OgEADDdpA3DOnDlx3333xZo1a+Jb3/pWrFu3LlpaWuLIkSP93mbJkiVRX19fOjU3N5dxYgCAE6NqfwR8PNdcc03pv88///y44IIL4qyzzoq1a9fGZZdd1udtFi1aFAsXLiyd7+rqEoEAwLCT9h3AN5o6dWqMHz8+tm3b1u+a2traqKur63UCABhuBOBfvfLKK7Fnz56YOHFipUcBABhUVfsj4H379vV6N6+1tTVeeOGFGDduXIwbNy7uuOOOuOqqq6KxsTFeeuml+OpXvxr/8A//ELNnz67g1AAAg69qA/A3v/lNfPSjHy2dP/rZvfnz58eyZcvit7/9bfz4xz+Ojo6OaGpqissvvzzuvPPOqK2trdTIAABlUbUBeMkll0RRFP1e//jjj5dxGgCAocNnAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACCZqg3Ap556Kq688spoamqKmpqaWLlyZa/ri6KI22+/PSZOnBinnHJKzJo1K7Zu3VqZYQEAyqhqA3D//v0xffr0WLp0aZ/Xf/vb344f/OAHcffdd8ezzz4bp512WsyePTsOHjxY5kkBAMprZKUHGCwtLS3R0tLS53VFUcT3v//9+NrXvhZz586NiIj77rsvGhoaYuXKlXHNNdeUc1QAgLKq2ncAj6W1tTXa2tpi1qxZpcvq6+tjxowZsX79+n5v193dHV1dXb1OAADDTcoAbGtri4iIhoaGXpc3NDSUruvLkiVLor6+vnRqbm4e1DkBAAZDygB8uxYtWhSdnZ2l044dOyo9EgDAgKUMwMbGxoiIaG9v73V5e3t76bq+1NbWRl1dXa8TAMBwkzIAp0yZEo2NjbFmzZrSZV1dXfHss8/GzJkzKzgZAMDgq9rfAt63b19s27atdL61tTVeeOGFGDduXEyePDluueWW+OY3vxnvfve7Y8qUKXHbbbdFU1NTzJs3r3JDAwCUQdUG4G9+85v46Ec/Wjq/cOHCiIiYP39+rFixIr761a/G/v374/Of/3x0dHTEhz/84Vi1alWMHj26UiMDAJRF1QbgJZdcEkVR9Ht9TU1NfOMb34hvfOMbZZwKAKDyUn4GEAAgMwEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDIjKz0Ax7Z58+ZKj8AQ0d3dHbW1tZUegyHEnqCa+f43uATgELVr166IGBHXX399pUdhyDgpIo5UegiGFHuC6jZixIi/fj/kRBOAQ1RHR0dE9ETE/RExrbLDMAQ8FhG3hf3A6zZHxPVx5513xhVXXFHpYeCE27x5c1x//fV//X7IiSYAh7xpEXFhpYeg4o7+KMR+oLcpU6bEhRfaE8DA+CUQAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkUgfg17/+9aipqel1Ovfccys9FgDAoBpZ6QEq7bzzzosnnniidH7kyPSHBACoculrZ+TIkdHY2FjpMQAAyib1j4AjIrZu3RpNTU0xderUuO6662L79u39ru3u7o6urq5eJwCA4SZ1AM6YMSNWrFgRq1atimXLlkVra2t85CMfib179/a5fsmSJVFfX186NTc3l3liAIB3LnUAtrS0xCc/+cm44IILYvbs2fHYY49FR0dHPPzww32uX7RoUXR2dpZOO3bsKPPEAADvXPrPAP6tsWPHxtlnnx3btm3r8/ra2tqora0t81QAACdW6ncA32jfvn3x0ksvxcSJEys9CgDAoEkdgF/5yldi3bp18ec//zmeeeaZ+Nd//dc46aST4tprr630aAAAgyb1j4BfeeWVuPbaa2PPnj1x+umnx4c//OHYsGFDnH766ZUeDQBg0KQOwIceeqjSIwAAlF3qHwEDAGQkAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIZmSlBwDg7Xv66acrPQIMitbW1kqPUNUEIMCwtCsiRsSyZcti2bJllR4GBsmIOHToUKWHqEoCEGBY6oiInoi4PyKmVXYUGBSbI+L6GDVqVKUHqUoCEGBYmxYRF1Z6CGCY8UsgAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJpA/ApUuXxplnnhmjR4+OGTNmxHPPPVfpkQAABlXqAPzJT34SCxcujMWLF8emTZti+vTpMXv27Hj11VcrPRoAwKBJHYB33XVXfO5zn4tPf/rT8Y//+I9x9913x6mnnhr33ntvpUcDABg0Iys9QKUcOnQoNm7cGIsWLSpdNmLEiJg1a1asX7++z9t0d3dHd3d36XxXV9egzxmxuQz/BkNf61//137gKHuCamdvD6a0Abh79+44cuRINDQ09Lq8oaEh/vjHP/Z5myVLlsQdd9xRjvFi6tSpEXFSRFxfln+P4WBE2A/0Zk9Q7U766/dDTrS0Afh2LFq0KBYuXFg639XVFc3NzYPyb82cOTOeeebX8ac//WlQ7p/h59ChQzFq1KhKj8EQYk9Q7aZOnRozZ86s9BhVKW0Ajh8/Pk466aRob2/vdXl7e3s0Njb2eZva2tqora0tx3gR8VoE2vgAwImW9pdARo0aFRdddFGsWbOmdFlPT0+sWbNGdAEAVS3tO4AREQsXLoz58+fH+9///rj44ovj+9//fuzfvz8+/elPV3o0AIBBkzoAr7766vjLX/4St99+e7S1tcV73/veWLVq1Zt+MQQAoJrUFEVRVHqI4aqrqyvq6+ujs7Mz6urqKj0OAPAW+P6d+DOAAABZCUAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJpP5TcO/U0T+i0tXVVeFJAIC36uj37cx/DE0AvgN79+6NiIjm5uYKTwIADNTevXujvr6+0mNUhL8F/A709PTEzp07Y8yYMVFTU3NC77urqyuam5tjx44daf9OYYTjcJTj8BrH4XWOxWsch9c4Dq97K8eiKIrYu3dvNDU1xYgROT8N5x3Ad2DEiBExadKkQf036urq0j+ZIxyHoxyH1zgOr3MsXuM4vMZxeN3xjkXWd/6Oypm9AACJCUAAgGQE4BBVW1sbixcvjtra2kqPUlGOw2sch9c4Dq9zLF7jOLzGcXidY/HW+CUQAIBkvAMIAJCMAAQASEYAAgAkIwABAJIRgBWydOnSOPPMM2P06NExY8aMeO655465/qc//Wmce+65MXr06Dj//PPjscceK9Okg2fJkiXxgQ98IMaMGRMTJkyIefPmxZYtW455mxUrVkRNTU2v0+jRo8s08eD4+te//qbHdO655x7zNtW4HyIizjzzzDcdi5qamliwYEGf66tlPzz11FNx5ZVXRlNTU9TU1MTKlSt7XV8URdx+++0xceLEOOWUU2LWrFmxdevW497vQF9nKu1Yx+Hw4cNx6623xvnnnx+nnXZaNDU1xb//+7/Hzp07j3mfb+f5NRQcb0/ccMMNb3pcc+bMOe79VtOeiIg+Xy9qamriO9/5Tr/3OVz3xIkmACvgJz/5SSxcuDAWL14cmzZtiunTp8fs2bPj1Vdf7XP9M888E9dee23ceOON8fzzz8e8efNi3rx58eKLL5Z58hNr3bp1sWDBgtiwYUOsXr06Dh8+HJdffnns37//mLerq6uLXbt2lU4vv/xymSYePOedd16vx/Q///M//a6t1v0QEfG///u/vY7D6tWrIyLik5/8ZL+3qYb9sH///pg+fXosXbq0z+u//e1vxw9+8IO4++6749lnn43TTjstZs+eHQcPHuz3Pgf6OjMUHOs4HDhwIDZt2hS33XZbbNq0KX72s5/Fli1b4uMf//hx73cgz6+h4nh7IiJizpw5vR7Xgw8+eMz7rLY9ERG9Hv+uXbvi3nvvjZqamrjqqquOeb/DcU+ccAVld/HFFxcLFiwonT9y5EjR1NRULFmypM/1n/rUp4qPfexjvS6bMWNG8YUvfGFQ5yy3V199tYiIYt26df2uWb58eVFfX1++ocpg8eLFxfTp09/y+iz7oSiK4ktf+lJx1llnFT09PX1eX437ISKKRx55pHS+p6enaGxsLL7zne+ULuvo6Chqa2uLBx98sN/7GejrzFDzxuPQl+eee66IiOLll1/ud81An19DUV/HYv78+cXcuXMHdD8Z9sTcuXOLSy+99JhrqmFPnAjeASyzQ4cOxcaNG2PWrFmly0aMGBGzZs2K9evX93mb9evX91ofETF79ux+1w9XnZ2dERExbty4Y67bt29fnHHGGdHc3Bxz586N3//+9+UYb1Bt3bo1mpqaYurUqXHdddfF9u3b+12bZT8cOnQo7r///vjMZz4TNTU1/a6rxv3wt1pbW6Otra3X17y+vj5mzJjR79f87bzODEednZ1RU1MTY8eOPea6gTy/hpO1a9fGhAkT4pxzzombbrop9uzZ0+/aDHuivb09fvnLX8aNN9543LXVuicGQgCW2e7du+PIkSPR0NDQ6/KGhoZoa2vr8zZtbW0DWj8c9fT0xC233BIf+tCH4j3veU+/684555y4995749FHH437778/enp64oMf/GC88sorZZz2xJoxY0asWLEiVq1aFcuWLYvW1tb4yEc+Env37u1zfYb9EBGxcuXK6OjoiBtuuKHfNdW4H97o6Nd1IF/zt/M6M9wcPHgwbr311rj22mujrq6u33UDfX4NF3PmzIn77rsv1qxZE9/61rdi3bp10dLSEkeOHOlzfYY98eMf/zjGjBkTn/jEJ465rlr3xECNrPQAEBGxYMGCePHFF4/7OYyZM2fGzJkzS+c/+MEPxrRp0+JHP/pR3HnnnYM95qBoaWkp/fcFF1wQM2bMiDPOOCMefvjht/T/ZKvVPffcEy0tLdHU1NTvmmrcDxzf4cOH41Of+lQURRHLli075tpqfX5dc801pf8+//zz44ILLoizzjor1q5dG5dddlkFJ6uce++9N6677rrj/iJYte6JgfIOYJmNHz8+TjrppGhvb+91eXt7ezQ2NvZ5m8bGxgGtH25uvvnm+MUvfhFPPvlkTJo0aUC3Pfnkk+N973tfbNu2bZCmK7+xY8fG2Wef3e9jqvb9EBHx8ssvxxNPPBGf/exnB3S7atwPR7+uA/mav53XmeHiaPy9/PLLsXr16mO++9eX4z2/hqupU6fG+PHj+31c1bwnIiJ+/etfx5YtWwb8mhFRvXvieARgmY0aNSouuuiiWLNmTemynp6eWLNmTa93Mv7WzJkze62PiFi9enW/64eLoiji5ptvjkceeSR+9atfxZQpUwZ8H0eOHInf/e53MXHixEGYsDL27dsXL730Ur+PqVr3w99avnx5TJgwIT72sY8N6HbVuB+mTJkSjY2Nvb7mXV1d8eyzz/b7NX87rzPDwdH427p1azzxxBPxrne9a8D3cbzn13D1yiuvxJ49e/p9XNW6J46655574qKLLorp06cP+LbVuieOq9K/hZLRQw89VNTW1hYrVqwo/vCHPxSf//zni7FjxxZtbW1FURTFv/3bvxX/+Z//WVr/9NNPFyNHjiy++93vFps3by4WL15cnHzyycXvfve7Sj2EE+Kmm24q6uvri7Vr1xa7du0qnQ4cOFBa88ZjcccddxSPP/548dJLLxUbN24srrnmmmL06NHF73//+0o8hBPiP/7jP4q1a9cWra2txdNPP13MmjWrGD9+fPHqq68WRZFnPxx15MiRYvLkycWtt976puuqdT/s3bu3eP7554vnn3++iIjirrvuKp5//vnSb7f+13/9VzF27Nji0UcfLX77298Wc+fOLaZMmVL83//9X+k+Lr300uKHP/xh6fzxXmeGomMdh0OHDhUf//jHi0mTJhUvvPBCr9eM7u7u0n288Tgc7/k1VB3rWOzdu7f4yle+Uqxfv75obW0tnnjiieLCCy8s3v3udxcHDx4s3Ue174mjOjs7i1NPPbVYtmxZn/dRLXviRBOAFfLDH/6wmDx5cjFq1Kji4osvLjZs2FC67l/+5V+K+fPn91r/8MMPF2effXYxatSo4rzzzit++ctflnniEy8i+jwtX768tOaNx+KWW24pHbeGhobiiiuuKDZt2lT+4U+gq6++upg4cWIxatSo4u///u+Lq6++uti2bVvp+iz74ajHH3+8iIhiy5Ytb7quWvfDk08+2edz4ehj7enpKW677baioaGhqK2tLS677LI3HZ8zzjijWLx4ca/LjvU6MxQd6zi0trb2+5rx5JNPlu7jjcfheM+voepYx+LAgQPF5ZdfXpx++unFySefXJxxxhnF5z73uTeFXLXviaN+9KMfFaecckrR0dHR531Uy5440WqKoigG9S1GAACGFJ8BBABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACCZ/wewHkkc0YsvXgAAAABJRU5ErkJggg=="}),Object(l.jsx)("div",{className:"space",children:"We now look to optimize wasted space in the other direction (vertically), so we partition vertically. Depending on how the rectangles are grouped, we'd have a different number of partitions. In this example, we have two partitions like this."}),Object(l.jsx)("img",{src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAYAAAA10dzkAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/Z1A+gAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAdbElEQVR4nO3df2zX9Z3A8VcrtDhHSxBp6agKbqhzym3eZN3cnVMi9BYH02xq3A133nYxuMxjyxzJKXO7pLcfccsWDveHwozx15KJmRoMMMFtgtxAs7l5CNpTDLRuJLSAgxL6uT8YX1dtQZT2235fj0fyjXy/3/f3y+v76fv75em336ZVRVEUAQBAGtXlHgAAgKElAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIZlS5BxjJent7Y/v27TF27Nioqqoq9zgAwFtQFEXs3r07mpqaoro653thAvAd2L59ezQ3N5d7DADgbdi2bVtMnjy53GOUhQB8B8aOHRsRhzZQXV1dmacBAN6K7u7uaG5uLv07npEAfAcOf9u3rq5OAALACJP541s5v/ENAJCYAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIZVe4BGNi6devixRdfLPcYwDDV09MTNTU15R4DBs3UqVOjpaWl3GNUJAE4TK1bty4uvPDC6O3tLfcowDBVXV3tNYKKVl1dHb/+9a9F4CAQgMPUiy++GL29vbFkyZKYNm1auccBhplVq1ZFW1ub1wgq1vPPPx/XX399vPjiiwJwEAjAYW7atGkxffr0co8BDDPPP/98RHiNAN4ePwQCAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJBMxQZgW1tbfPjDH46xY8fGxIkTY+7cubF58+Y+a/bt2xfz58+Pk08+Od797nfHFVdcEZ2dnWWaGABgaFRsAK5duzbmz58f69evj5UrV8aBAwfi0ksvjb1795bW/Pu//3v84he/iJ/97Gexdu3a2L59e1x++eVlnBoAYPBV7O8CXrFiRZ/zy5Yti4kTJ8bGjRvjH/7hH6KrqyvuuOOOuOeee+Liiy+OiIilS5fG2WefHevXr4+PfOQj5RgbAGDQVew7gG/U1dUVERHjx4+PiIiNGzfGgQMHYubMmaU1Z511Vpx66qmxbt26fu9j//790d3d3ecEADDSpAjA3t7euPHGG+NjH/tYfOADH4iIiI6OjqipqYlx48b1WdvQ0BAdHR393k9bW1vU19eXTs3NzYM9OgDAcZciAOfPnx/PPvts3Hfffe/ofhYuXBhdXV2l07Zt247ThAAAQ6diPwN42A033BAPP/xwPPHEEzF58uTS5Y2NjdHT0xO7du3q8y5gZ2dnNDY29ntftbW1UVtbO9gjAwAMqop9B7AoirjhhhviwQcfjF/+8pcxZcqUPteff/75MXr06Fi9enXpss2bN8fLL78cLS0tQz0uAMCQqdh3AOfPnx/33HNPPPTQQzF27NjS5/rq6+vjxBNPjPr6+rjuuutiwYIFMX78+Kirq4svf/nL0dLS4ieAAYCKVrEBuGTJkoiIuOiii/pcvnTp0rj22msjIuIHP/hBVFdXxxVXXBH79++PWbNmxX//938P8aQAAEOrYgOwKIqjrhkzZkwsXrw4Fi9ePAQTAQAMDxX7GUAAAPonAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMhUbgE888URcdtll0dTUFFVVVbF8+fI+11977bVRVVXV5zR79uzyDAsAMIQqNgD37t0b06dPj8WLFw+4Zvbs2bFjx47S6d577x3CCQEAymNUuQcYLK2trdHa2nrENbW1tdHY2DhEEwEADA8V+w7gW7FmzZqYOHFinHnmmXH99dfHzp07j7h+//790d3d3ecEADDSpA3A2bNnx1133RWrV6+O73znO7F27dpobW2NgwcPDnibtra2qK+vL52am5uHcGIAgOOjYr8FfDRXXXVV6c/nnntunHfeeXHGGWfEmjVr4pJLLun3NgsXLowFCxaUznd3d4tAAGDESfsO4BtNnTo1JkyYEFu3bh1wTW1tbdTV1fU5AQCMNALwr1555ZXYuXNnTJo0qdyjAAAMqor9FvCePXv6vJvX3t4ezzzzTIwfPz7Gjx8ft956a1xxxRXR2NgYL7zwQnz961+P9773vTFr1qwyTg0AMPgqNgB/+9vfxic+8YnS+cOf3Zs3b14sWbIkfve738VPf/rT2LVrVzQ1NcWll14a3/72t6O2trZcIwMADImKDcCLLrooiqIY8PrHHntsCKcBABg+fAYQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkqnYAHziiSfisssui6ampqiqqorly5f3ub4oirjlllti0qRJceKJJ8bMmTNjy5Yt5RkWAGAIVWwA7t27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Duvq6ire9a53FUuWLOn3PiplTxxvArBMfvzjHxennnpqUVNTU1xwwQXF+vXrS9f94z/+YzFv3rw+6x944IFi2rRpRU1NTXHOOecUjzzyyBBPfPxFRL+npUuXlta88VjceOONpePW0NBQ/NM//VOxadOmoR/+OLryyiuLSZMmFTU1NcV73vOe4sorryy2bt1auj7LfjjsscceKyKi2Lx585uuq9T98Pjjj/f7XDj8WHt7e4ubb765aGhoKGpra4tLLrnkTcfntNNOKxYtWtTnsiO9zgxHRzoO7e3tA75mPP7446X7eONxONrza7g60rF47bXXiksvvbQ45ZRTitGjRxennXZa8cUvfvFNIVfpe+Kwn/zkJ8WJJ55Y7Nq1q9/7qJQ9cbxVFUVRDOpbjAAADCs+AwgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMv8P6bZOEoKJIZwAAAAASUVORK5CYII="}),Object(l.jsxs)("div",{className:"space",children:["We call the function and ask it to pack into each of these grey rectangles, only this optimizing wasted space vertically. You'll notice that this time, the function will have a convenient ",Object(l.jsx)(j.a,{children:"$L$"})," for each of the grey rectangles, so we expect it to do a fairly decent job."]}),Object(l.jsx)("img",{src:"data:image/png;base64,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khGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACRTV/YAnMqWsgdgQDi+DtasWRP//d//XfIsDAQvvfRS2SMAg5gAHKCGDRsWx1+gvaPsURgwamPx4sVlDwFAFRCAA9S4ceMioisiFkVEa8nTUL5nImJpRDwcEZeWPAsDwxMRsaDsIYBBSgAOeNdHxBVlD8GAsDSOx5/1QISPhwBnwpdAAACSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAydWUPAMCZ2FL2AFAh1nYlCUCAQelwHH8T546yB4EKqo2jR4+WPURVEoAAg9LQiOiKiEUR0VryLFAJbRGxIOrqpEolOKoAg9r1EXFF2UNABWyOiAVlD1G1fAkEACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACCZ1AH4pS99KWpqanqcLrnkkrLHAgCoqPS/Cm7SpEmxZs2a7vN+5yAAUO3S105dXV00NTWVPQYAQL9J/RZwRMS2bduiubk5JkyYELfffnu8+uqrfW7b2dkZHR0dPU4AAINN6gCcMmVKLF++PFatWhVLly6Ntra2+NjHPhb79+/vdfvFixdHQ0ND96mlpaWfJwYAOHOpA3DmzJnxqU99Ki6//PKYPn16PPHEE7F379547LHHet1+/vz5sW/fvu7Tzp07+3liAIAzl/4zgL9p1KhRMXHixNi+fXuv19fX10d9fX0/TwUAcHalfgXw7Q4cOBA7duyIcePGlT0KAEDFpA7AL3zhC7F+/fr43//933j22WfjxhtvjCFDhsRtt91W9mgAABWT+i3g1157LW677bZ444034vzzz4+PfvSjsXHjxjj//PPLHg0AoGJSB+Cjjz5a9ggAAP0u9VvAAAAZCUAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkqkrewAAzsSW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wnIcOHAgduzY0ed9qtb18JuWLVsWY8eOjU984hOndbtqXA+tra3R1NTU42fe0dERzz33XJ8/8/fyPDMYnIi/bdu2xZo1a+K888477X2c6vE1WL322mvxxhtv9Hm/qnVNnPDggw/GlVdeGZMnTz7t21brmjilsr+FktGjjz5a1NfXF8uXLy/+8z//s/jc5z5XjBo1qtizZ09RFEXxp3/6p8Xf/d3fdW//zDPPFHV1dcU///M/F1u2bCkWLlxYnHPOOcUvfvGLsu7CWfH5z3++aGhoKNatW1fs3r27+/Tmm292b/P2Y3H//fcXTz75ZLFjx45i06ZNxa233loMGzasePnll8u4C2fF3/7t3xbr1q0r2traimeeeaaYNm1aMWbMmOL1118viiLPejjh2LFjxQUXXFDce++977iuWtfD/v37ixdeeKF44YUXiogovv71rxcvvPBC97db//Ef/7EYNWpU8fjjjxc///nPi1mzZhWtra3Fr371q+59XHPNNcW3vvWt7vOnep4ZiE52HA4fPlx88pOfLMaPH1+8+OKLPZ4zOjs7u/fx9uNwqsfXQHWyY7F///7iC1/4QrFhw4aira2tWLNmTXHFFVcU73//+4tDhw5176Pa18QJ+/btK973vvcVS5cu7XUf1bImzjYBWJJvfetbxQUXXFAMHTq0uOqqq4qNGzd2X/cnf/InxZw5c3ps/9hjjxUTJ04shg4dWkyaNKn48Y9/3M8Tn30R0etp2bJl3du8/Vjcc8893cetsbGxuP7664vNmzf3//Bn0S233FKMGzeuGDp0aPE7v/M7xS233FJs3769+/os6+GEJ598soiIYuvWre+4rlrXw1NPPdXrY+HEfe3q6ioWLFhQNDY2FvX19cW11177juNz4YUXFgsXLuxx2cmeZwaikx2Htra2Pp8znnrqqe59vP04nOrxNVCd7Fi8+eabxXXXXVecf/75xTnnnFNceOGFxWc/+9l3hFy1r4kTvv3tbxfDhw8v9u7d2+s+qmVNnG01RVEUFX2JEQCAAcVnAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABI5v8He6t/kWq4OOoAAAAASUVORK5CYII="}),Object(l.jsx)("div",{className:"space",children:"As it turns out, it packs one of these rectangles pretty well, but there's wasted horizontal space for the left grey rectangle. No worries, because if we further partition this one into two more rectangles horizontally and ask the function to optimize it, it will happily do so."}),Object(l.jsx)("img",{src:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAYAAAA10dzkAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjQuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/Z1A+gAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAfg0lEQVR4nO3df4zX9X3A8dcdcId1cAyRO24cerhaHVU2XWHYulolAjYWqrFqdEPn2qXBZY41dSxDamlyW7t0TRuG/UOhjanWJhOz1mCACnYKsoKutXMM8CYYfriawAEOjnCf/cG49vQORPje5+77ejySb+T7/X6+H17fz72/X59+f3g1RVEUAQBAGrVlDwAAQP8SgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkM7TsAQazrq6u2LVrV4wYMSJqamrKHgcAeA+KoogDBw5Ec3Nz1NbmfC1MAJ6BXbt2RUtLS9ljAADvw86dO2P8+PFlj1EKAXgGRowYERHHF9DIkSNLngYAeC86OjqipaWl+9/jGQnAM3Dibd+RI0cKQAAYZDJ/fCvnG98AAIkJQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIJmhZQ9A39avXx+vvfZa2WMwQHR2dkZdXV3ZYzCAWBNUu4kTJ8a0adPKHqMqCcABav369XHVVVdHxLGyR2HAqI2IrrKHYECxJqh2Q+KFF34iAitAAA5Qx1/5OxYRj0bEpSVPQ/lejYg7Y8GCBTF9+vSyh2EAWL16dbS1tYXnCKrX8ee91157TQBWgAAc8C6NiCvKHoIBYsKECTF58uSyx2AA+K//+q///5PnCOD0+RIIAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyVRuAbW1t8ZGPfCRGjBgRY8eOjTlz5sSWLVt6bHP48OGYN29enHfeefEbv/EbcfPNN8fevXtLmhgAoH9UbQCuW7cu5s2bFxs2bIhVq1bF0aNH4/rrr49Dhw51b/OXf/mX8S//8i/xgx/8INatWxe7du2Km266qcSpAQAqr2p/F/DKlSt7nF++fHmMHTs2Nm3aFH/4h38Y+/fvj4cffji+973vxbXXXhsREcuWLYtLL700NmzYEH/wB39QxtgAABVXta8AvtP+/fsjImL06NEREbFp06Y4evRoTJ8+vXubSy65JCZMmBDr16/vdR9HjhyJjo6OHicAgMEmRQB2dXXFfffdFx/96Efjwx/+cERE7NmzJ+rq6mLUqFE9tm1sbIw9e/b0up+2trZoaGjoPrW0tFR6dACAsy5FAM6bNy9eeeWVePzxx89oPwsWLIj9+/d3n3bu3HmWJgQA6D9V+xnAE+6999744Q9/GM8991yMHz+++/Kmpqbo7OyMffv29XgVcO/evdHU1NTrvurr66O+vr7SIwMAVFTVvgJYFEXce++98eSTT8aPf/zjaG1t7XH9lVdeGcOGDYs1a9Z0X7Zly5bYsWNHTJs2rb/HBQDoN1X7CuC8efPie9/7Xjz11FMxYsSI7s/1NTQ0xDnnnBMNDQ1xzz33xPz582P06NExcuTI+PM///OYNm2abwADAFWtagNw6dKlERFxzTXX9Lh82bJlcdddd0VExD/+4z9GbW1t3HzzzXHkyJGYMWNG/NM//VM/TwoA0L+qNgCLojjlNsOHD48lS5bEkiVL+mEiAICBoWo/AwgAQO8EIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJDC17AADOxKtlDwAVYm1XkgAEGISOHj0ax9/EubPsUaCCaqOzs7PsIaqSAAQYhIYNGxYRXRGxOCJaS54GKqE9IhZGXV1d2YNUJQEIMKjdEBFXlD0EVMDmiFhY9hBVy5dAAACSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSqdoAfO655+LGG2+M5ubmqKmpiRUrVvS4/q677oqampoep5kzZ5YzLABAP6raADx06FBMnjw5lixZ0uc2M2fOjN27d3efHnvssX6cEACgHEPLHqBSZs2aFbNmzTrpNvX19dHU1NRPEwEADAxVG4Dvxdq1a2Ps2LHxm7/5m3HttdfGV77ylTjvvPP63P7IkSNx5MiR7vMdHR39MSbASbxa9gBQIdZ2JaUNwJkzZ8ZNN90Ura2tsX379vibv/mbmDVrVqxfvz6GDBnS623a2triwQcf7OdJAd7t6NGjcfxTPHeWPQpUUG10dnaWPURVShuAt912W/efL7vssrj88svjoosuirVr18Z1113X620WLFgQ8+fP7z7f0dERLS0tFZ8V4J2GDRsWEV0RsTgiWkueBiqhPSIWRl1dXdmDVKW0AfhOEydOjDFjxsS2bdv6DMD6+vqor6/v58kATuaGiLii7CGgAjZHxMKyh6haVfst4NP1xhtvxFtvvRXjxo0rexQAgIqq2lcADx48GNu2bes+397eHi+//HKMHj06Ro8eHQ8++GDcfPPN0dTUFNu3b48vfvGL8du//dsxY8aMEqcGAKi8qg3An/70p/GJT3yi+/yJz+7NnTs3li5dGj/72c/iO9/5Tuzbty+am5vj+uuvj8WLF3uLFwCoelUbgNdcc00URdHn9c8880w/TgMAMHD4DCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkqvZ/BF09Xi17AAaE4+tgx44d8e///u8lz8JAsGPHjrJHAAYxAThAdXZ2xvEXaO8sexQGjNpoa2uLtra2sgcBYJATgANUXV1dRHRFxOKIaC15GsrXHhEL4+67744pU6aUPQwDwMaNG2PZsmVljwEMUgJwwLshIq4oewhKtzkiFsaUKVPilltuKXsYBggBCLxfvgQCAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIZWvYAAJyJV8seACrE2q4kAQgwCB09ejSOv4lzZ9mjQAXVRmdnZ9lDVCUBCDAIDRs2LCK6ImJxRLSWPA1UQntELIy6urqyB6lKAhBgULshIq4oewiogM0RsbDsIaqWL4EAACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACRTtQH43HPPxY033hjNzc1RU1MTK1as6HF9URTxwAMPxLhx4+Kcc86J6dOnx9atW8sZFgCgH1VtAB46dCgmT54cS5Ys6fX6r371q/HNb34zHnrooXjxxRfj3HPPjRkzZsThw4f7eVIAgP41tOwBKmXWrFkxa9asXq8riiK+8Y1vxN/+7d/G7NmzIyLiu9/9bjQ2NsaKFSvitttu689RAQD6VdW+Angy7e3tsWfPnpg+fXr3ZQ0NDTF16tRYv359n7c7cuRIdHR09DgBAAw2KQNwz549ERHR2NjY4/LGxsbu63rT1tYWDQ0N3aeWlpaKzgkAUAkpA/D9WrBgQezfv7/7tHPnzrJHAgA4bSkDsKmpKSIi9u7d2+PyvXv3dl/Xm/r6+hg5cmSPEwDAYJMyAFtbW6OpqSnWrFnTfVlHR0e8+OKLMW3atBInAwCovKr9FvDBgwdj27Zt3efb29vj5ZdfjtGjR8eECRPivvvui6985SvxwQ9+MFpbW2PhwoXR3Nwcc+bMKW9oAIB+ULUB+NOf/jQ+8YlPdJ+fP39+RETMnTs3li9fHl/84hfj0KFD8bnPfS727dsXH/vYx2LlypUxfPjwskYGAOgXVRuA11xzTRRF0ef1NTU18eUvfzm+/OUv9+NUAADlS/kZQACAzAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMlU7f8IGiCHV8seACrE2q4kAQgwCB09ejSOv4lzZ9mjQAXVRmdnZ9lDVCUBCDAIDRs2LCK6ImJxRLSWPA1UQntELIy6urqyB6lKAhBgULshIq4oewiogM0RsbDsIaqWL4EAACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGSGlj0Ap/Jq2QMwIBxfBxs3bix5DgYKawE4EwJwgOrs7IzjL9DeWfYoDBi1sWzZsli2bFnZgwAwyAnAAaquri4iuiJicUS0ljwN5Xs+IpZGxKMRcWnJszAwPB0RC8seAhikBOCAd0NEXFH2EAwIS+N4/FkPRPh4CHAmfAkEACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQztOwBADgTr5Y9AFSItV1JAhBgUOqM42/i3Fn2IFBBtdHZ2Vn2EFVJAAIMSnUR0RURiyOiteRZoBLaI2Jh1NXVlT1IVRKAAIPaDRFxRdlDQAVsjoiFZQ9RtXwJBAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgmdQB+KUvfSlqamp6nC655JKyxwIAqKj0vwpu0qRJsXr16u7zQ4emPyQAQJVLXztDhw6NpqamsscAAOg3qd8CjojYunVrNDc3x8SJE+OOO+6IHTt29LntkSNHoqOjo8cJAGCwSR2AU6dOjeXLl8fKlStj6dKl0d7eHldffXUcOHCg1+3b2tqioaGh+9TS0tLPEwMAnLnUAThr1qy45ZZb4vLLL48ZM2bE008/Hfv27Ysnnnii1+0XLFgQ+/fv7z7t3LmznycGADhz6T8D+OtGjRoVF198cWzbtq3X6+vr66O+vr6fpwIAOLtSvwL4TgcPHozt27fHuHHjyh4FAKBiUgfgF77whVi3bl3893//d7zwwgvx6U9/OoYMGRK333572aMBAFRM6reA33jjjbj99tvjrbfeivPPPz8+9rGPxYYNG+L8888vezQAgIpJHYCPP/542SMAAPS71G8BAwBkJAABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASGZo2QMAcCZeLXsAqBBru5IEIMCgtDuOv4lzZ9mDQAXVxu7du8seoioJQIBB6XBEdEXE4ohoLXkWqIT2iFgYhw8fLnuQqiQAAQa1GyLiirKHgArYHBELyx6iavkSCABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMukDcMmSJXHhhRfG8OHDY+rUqbFx48ayRwIAqKjUAfj9738/5s+fH4sWLYrNmzfH5MmTY8aMGfHmm2+WPRoAQMWkDsCvf/3r8dnPfjbuvvvu+J3f+Z146KGH4gMf+EA88sgjZY8GAFAxQ8seoCydnZ2xadOmWLBgQfdltbW1MX369Fi/fn2vtzly5EgcOXKk+3xHR0fF54x4tR/+Dga+9v//p/XACbv+/5/WBNXK2q6ktAH4y1/+Mo4dOxaNjY09Lm9sbIz//M//7PU2bW1t8eCDD/bHeDFx4sSIGBIRd/bL38dgUBvWAz1ZE1S72pg0aVLZQ1SltAH4fixYsCDmz5/ffb6joyNaWloq8ndNmzYtXnjhJ/Haa69VZP8MPp2dnVFXV1f2GAwgu3fvjsOHD5c9BlTMpEmT4tOf/nTZY1SltAE4ZsyYGDJkSOzdu7fH5Xv37o2mpqZeb1NfXx/19fX9MV5EHI/AadOm9dvfBwDkkPZLIHV1dXHllVfGmjVrui/r6uqKNWvWiC4AoKqlfQUwImL+/Pkxd+7c+P3f//2YMmVKfOMb34hDhw7F3XffXfZoAAAVkzoAb7311vif//mfeOCBB2LPnj3xu7/7u7Fy5cp3fTEEAKCa1BRFUZQ9xGDV0dERDQ0NsX///hg5cmTZ4wAA74F/fyf+DCAAQFYCEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDKpfxXcmTrxS1Q6OjpKngQAeK9O/Hs78y9DE4Bn4MCBAxER0dLSUvIkAMDpOnDgQDQ0NJQ9Rin8LuAz0NXVFbt27YoRI0ZETU3NWd13R0dHtLS0xM6dO9P+nsIIx+EEx+E4x+FXHIvjHIfjHIdfeS/HoiiKOHDgQDQ3N0dtbc5Pw3kF8AzU1tbG+PHjK/p3jBw5Mv2DOcJxOMFxOM5x+BXH4jjH4TjH4VdOdSyyvvJ3Qs7sBQBITAACACQjAAeo+vr6WLRoUdTX15c9Sqkch+Mch+Mch19xLI5zHI5zHH7FsXhvfAkEACAZrwACACQjAAEAkhGAAADJCEAAgGQEYEmWLFkSF154YQwfPjymTp0aGzduPOn2P/jBD+KSSy6J4cOHx2WXXRZPP/10P01aOW1tbfGRj3wkRowYEWPHjo05c+bEli1bTnqb5cuXR01NTY/T8OHD+2niyvjSl770rvt0ySWXnPQ21bgeIiIuvPDCdx2LmpqamDdvXq/bV8t6eO655+LGG2+M5ubmqKmpiRUrVvS4viiKeOCBB2LcuHFxzjnnxPTp02Pr1q2n3O/pPs+U7WTH4ejRo3H//ffHZZddFueee240NzfHH//xH8euXbtOus/38/gaCE61Ju6666533a+ZM2eecr/VtCYiotfni5qamvja177W5z4H65o42wRgCb7//e/H/PnzY9GiRbF58+aYPHlyzJgxI958881et3/hhRfi9ttvj3vuuSdeeumlmDNnTsyZMydeeeWVfp787Fq3bl3MmzcvNmzYEKtWrYqjR4/G9ddfH4cOHTrp7UaOHBm7d+/uPr3++uv9NHHlTJo0qcd9+td//dc+t63W9RAR8W//9m89jsOqVasiIuKWW27p8zbVsB4OHToUkydPjiVLlvR6/Ve/+tX45je/GQ899FC8+OKLce6558aMGTPi8OHDfe7zdJ9nBoKTHYe33347Nm/eHAsXLozNmzfHP//zP8eWLVviU5/61Cn3ezqPr4HiVGsiImLmzJk97tdjjz120n1W25qIiB73f/fu3fHII49ETU1N3HzzzSfd72BcE2ddQb+bMmVKMW/evO7zx44dK5qbm4u2trZet//MZz5TfPKTn+xx2dSpU4s/+7M/q+ic/e3NN98sIqJYt25dn9ssW7asaGho6L+h+sGiRYuKyZMnv+fts6yHoiiKv/iLvyguuuiioqurq9frq3E9RETx5JNPdp/v6uoqmpqaiq997Wvdl+3bt6+or68vHnvssT73c7rPMwPNO49DbzZu3FhERPH666/3uc3pPr4Got6Oxdy5c4vZs2ef1n4yrInZs2cX11577Um3qYY1cTZ4BbCfdXZ2xqZNm2L69Ondl9XW1sb06dNj/fr1vd5m/fr1PbaPiJgxY0af2w9W+/fvj4iI0aNHn3S7gwcPxgUXXBAtLS0xe/bs+MUvftEf41XU1q1bo7m5OSZOnBh33HFH7Nixo89ts6yHzs7OePTRR+NP/uRPoqamps/tqnE9/Lr29vbYs2dPj595Q0NDTJ06tc+f+ft5nhmM9u/fHzU1NTFq1KiTbnc6j6/BZO3atTF27Nj40Ic+FJ///Ofjrbfe6nPbDGti79698aMf/SjuueeeU25brWvidAjAfvbLX/4yjh07Fo2NjT0ub2xsjD179vR6mz179pzW9oNRV1dX3HffffHRj340PvzhD/e53Yc+9KF45JFH4qmnnopHH300urq64qqrroo33nijH6c9u6ZOnRrLly+PlStXxtKlS6O9vT2uvvrqOHDgQK/bZ1gPERErVqyIffv2xV133dXnNtW4Ht7pxM/1dH7m7+d5ZrA5fPhw3H///XH77bfHyJEj+9zudB9fg8XMmTPju9/9bqxZsyb+/u//PtatWxezZs2KY8eO9bp9hjXxne98J0aMGBE33XTTSber1jVxuoaWPQBERMybNy9eeeWVU34OY9q0aTFt2rTu81dddVVceuml8e1vfzsWL15c6TErYtasWd1/vvzyy2Pq1KlxwQUXxBNPPPGe/ku2Wj388MMxa9asaG5u7nObalwPnNrRo0fjM5/5TBRFEUuXLj3pttX6+Lrtttu6/3zZZZfF5ZdfHhdddFGsXbs2rrvuuhInK88jjzwSd9xxxym/CFata+J0eQWwn40ZMyaGDBkSe/fu7XH53r17o6mpqdfbNDU1ndb2g829994bP/zhD+PZZ5+N8ePHn9Zthw0bFr/3e78X27Ztq9B0/W/UqFFx8cUX93mfqn09RES8/vrrsXr16vjTP/3T07pdNa6HEz/X0/mZv5/nmcHiRPy9/vrrsWrVqpO++tebUz2+BquJEyfGmDFj+rxf1bwmIiJ+8pOfxJYtW077OSOietfEqQjAflZXVxdXXnllrFmzpvuyrq6uWLNmTY9XMn7dtGnTemwfEbFq1ao+tx8siqKIe++9N5588sn48Y9/HK2trae9j2PHjsXPf/7zGDduXAUmLMfBgwdj+/btfd6nal0Pv27ZsmUxduzY+OQnP3lat6vG9dDa2hpNTU09fuYdHR3x4osv9vkzfz/PM4PBifjbunVrrF69Os4777zT3sepHl+D1RtvvBFvvfVWn/erWtfECQ8//HBceeWVMXny5NO+bbWuiVMq+1soGT3++ONFfX19sXz58uI//uM/is997nPFqFGjij179hRFURR/9Ed/VPz1X/919/bPP/98MXTo0OIf/uEfildffbVYtGhRMWzYsOLnP/95WXfhrPj85z9fNDQ0FGvXri12797dfXr77be7t3nnsXjwwQeLZ555pti+fXuxadOm4rbbbiuGDx9e/OIXvyjjLpwVf/VXf1WsXbu2aG9vL55//vli+vTpxZgxY4o333yzKIo86+GEY8eOFRMmTCjuv//+d11XrevhwIEDxUsvvVS89NJLRUQUX//614uXXnqp+9utf/d3f1eMGjWqeOqpp4qf/exnxezZs4vW1tbif//3f7v3ce211xbf+ta3us+f6nlmIDrZcejs7Cw+9alPFePHjy9efvnlHs8ZR44c6d7HO4/DqR5fA9XJjsWBAweKL3zhC8X69euL9vb2YvXq1cUVV1xRfPCDHywOHz7cvY9qXxMn7N+/v/jABz5QLF26tNd9VMuaONsEYEm+9a1vFRMmTCjq6uqKKVOmFBs2bOi+7uMf/3gxd+7cHts/8cQTxcUXX1zU1dUVkyZNKn70ox/188RnX0T0elq2bFn3Nu88Fvfdd1/3cWtsbCxuuOGGYvPmzf0//Fl06623FuPGjSvq6uqK3/qt3ypuvfXWYtu2bd3XZ1kPJzzzzDNFRBRbtmx513XVuh6effbZXh8LJ+5rV1dXsXDhwqKxsbGor68vrrvuuncdnwsuuKBYtGhRj8tO9jwzEJ3sOLS3t/f5nPHss8927+Odx+FUj6+B6mTH4u233y6uv/764vzzzy+GDRtWXHDBBcVnP/vZd4Vcta+JE7797W8X55xzTrFv375e91Eta+JsqymKoqjoS4wAAAwoPgMIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDL/B/jElgMIMm5SAAAAAElFTkSuQmCC"}),Object(l.jsx)("br",{}),Object(l.jsx)("img",{src:"data:image/png;base64,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vkar1157Ld58880h71e1romj7r///rjsssti5syZJ3zbal0Tx1X2t1Ayevjhh4u6urpizZo1xX/9138Vn//854tJkyYVHR0dRVEUxZ/+6Z8Wf/d3f9e//TPPPFOMGzeu+Od//udi27ZtxbJly4rTTjut+MUvflHWXTglvvCFLxT19fXFxo0bi9dff73/9NZbb/Vv885jce+99xZPPPFEsWvXrmLLli3FzTffXIwfP7745S9/WcZdOCX+9m//tti4cWPR3t5ePPPMM8WcOXOKKVOmFG+88UZRFHnWw1GHDx8uzj777OLuu+9+13XVuh727dtXvPDCC8ULL7xQRETxjW98o3jhhRf6v936j//4j8WkSZOKxx57rPj5z39ezJ8/v2hpaSn+7//+r38fV199dfHtb3+7//zxnmdGomMdh97e3uJTn/pUMX369OLFF18c8JzR09PTv493HofjPb5GqmMdi3379hVf/OIXi7a2tqK9vb148skni0svvbT44Ac/WBw8eLB/H9W+Jo7q6uoqPvCBDxSrVq0adB/VsiZONQFYkm9/+9vF2WefXdTW1haXX355sXnz5v7rPv7xjxcLFy4csP0jjzxSnH/++UVtbW1x0UUXFT/+8Y+HeeJTLyIGPa1evbp/m3cei7vuuqv/uDU0NBTXXXddsXXr1uEf/hS66aabimnTphW1tbXF7/zO7xQ33XRTsXPnzv7rs6yHo5544okiIort27e/67pqXQ9PPfXUoI+Fo/e1r6+vWLp0adHQ0FDU1dUV11xzzbuOzznnnFMsW7ZswGXHep4ZiY51HNrb24d8znjqqaf69/HO43C8x9dIdaxj8dZbbxXXXnttcdZZZxWnnXZacc455xSf+9zn3hVy1b4mjvrOd75TnH766cXevXsH3Ue1rIlTraYoiqKiLzECADCi+AwgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMkIQACAZAQgAEAyAhAAIBkBCACQjAAEAEhGAAIAJCMAAQCSEYAAAMn8Py/La5GjbQmLAAAAAElFTkSuQmCC"}),Object(l.jsx)("div",{className:"space",children:"At this point, we're done because we have no more rectangles to fill (Of course, we would also be done if there were more rectangles to be filled, but if all of them were smaller than every smaller rectangle). Also note that this whole process mentioned so for calculated possible combinations just for the first rectangle (5, 7). For each recursive call to the function we loop over each rectangle, but to prevent combinatorial explosion, the function only returns the one combination that minimizes wasted length (or height)."}),Object(l.jsx)("div",{className:"space",children:"And finally, because this is a heuristic, always optimizing the lengths and widths might not always be a good idea. Consider this case: Here the red rectangle is a perfect fit horizontally but its height prevents more rectangles from being packed on top of it."}),Object(l.jsx)("img",{src:"data:image/png;base64,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"}),Object(l.jsx)("div",{className:"space",children:"There are ways to optimize this, but I found that a quick fix is to run the rectangle packing algorithm a bunch of times, each time removing one rectangle randomly. For example, running the previous example without the (3, 7) rectangle gives us the optimal solution."}),Object(l.jsx)("img",{src:"data:image/png;base64,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IwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyQhAAIBkBCAAQDICEAAgGQEIAJCMAAQASEYAAgAkIwABAJIRgAAAyaQNwD179sScOXOisbExBg0aFCeccELccsstURRF2dMAACrqkLIHlOWOO+6IhQsXxv333x8nn3xyvPTSSzFz5syora2N6667rux5AAAVkzYA//jHP8bFF18cF154YUREHHfccfHwww/HCy+8UPIyAIDKSvsS8Oc+97lYunRpvPrqqxER8ec//zmeffbZmDJlyj4f09bWFq2trV0uAAC9TdozgDfeeGO0trbG6NGjY8CAAbFnz5647bbb4vLLL9/nY1paWmLevHnduBIA4OBLewbwscceiwcffDAeeuihWL16ddx///3xk5/8JO6///59Pmb27Nmxc+fOzsumTZu6cTEAwMGR9gzgd7/73bjxxhvjsssui4iIU045Jf72t79FS0tLzJgxY6+Pqa6ujurq6u6cCQBw0KU9A/j2229H//5d//MHDBgQHR0dJS0CAOgeac8ATp06NW677bYYOXJknHzyyfGnP/0p7rrrrvjGN75R9jQAgIpKG4D33HNPzJkzJ66++urYtm1b1NfXx7e+9a246aabyp4GAFBRaQOwpqYm5s+fH/Pnzy97CgBAt0r7HkAAgKwEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMqkD8B//+EdMnz49jjrqqBg0aFCccsop8dJLL5U9CwCgog4pe0BZ/vWvf8XZZ58d5557bvz+97+PY445JtatWxdHHnlk2dMAACoqbQDecccd0dDQEPfee2/nbY2NjSUuAgDoHmkD8De/+U1Mnjw5vvrVr8by5cvj2GOPjauvvjquvPLKfT6mra0t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JkyIF154oexJ7MUPf/jD6NevX5fL6NGjy55FRKxYsSKmTp0a9fX10a9fv3jiiSe6fLwoirjpppuirq4uBg0aFJMmTYp169aVMza5j3quvv71r3/oOLvgggvKGZtcS0tLnHXWWVFTUxNDhw6NadOmxdq1a7vc55133ommpqY46qij4hOf+ERccsklsXXr1pIWsz8CsId59NFHo7m5OebOnRurV6+OcePGxeTJk2Pbtm1lT2MvTj755HjjjTc6L88++2zZk4iI3bt3x7hx42LBggV7/fidd94Zd999dyxatCief/75OPzww2Py5MnxzjvvdPNSPuq5ioi44IILuhxnDz/8cDcu5APLly+PpqameO655+Lpp5+Od999N84///zYvXt3532uv/76+O1vfxuPP/54LF++PDZv3hxf+cpXSlzNPhX0KOPHjy+ampo6r+/Zs6eor68vWlpaSlzF3sydO7cYN25c2TP4CBFRLF68uPN6R0dHMXz48OLHP/5x5207duwoqquri4cffriEhXzgP5+roiiKGTNmFBdffHEpe9i/bdu2FRFRLF++vCiK946jQw89tHj88cc777NmzZoiIoqVK1eWNZN9cAawB2lvb49Vq1bFpEmTOm/r379/TJo0KVauXFniMvZl3bp1UV9fH8cff3xcfvnlsXHjxrIn8RE2bNgQW7Zs6XKc1dbWxoQJExxnPdSyZcti6NCh8elPfzquuuqqePPNN8ueRETs3LkzIiKGDBkSERGrVq2Kd999t8uxNXr06Bg5cqRjqwcSgD3I9u3bY8+ePTFs2LAutw8bNiy2bNlS0ir2ZcKECXHffffFkiVLYuHChbFhw4b4whe+ELt27Sp7GvvxwbHkOOsdLrjggnjggQdi6dKlcccdd8Ty5ctjypQpsWfPnrKnpdbR0RGzZs2Ks88+O8aOHRsR7x1bVVVVccQRR3S5r2OrZzqk7AHQW02ZMqXz96eeempMmDAhRo0aFY899lhcccUVJS6DvuOyyy7r/P0pp5wSp556apxwwgmxbNmyOO+880pclltTU1O88sor3vfcizkD2IMcffTRMWDAgA99x9TWrVtj+PDhJa3iQB1xxBHxqU99KtavX1/2FPbjg2PJcdY7HX/88XH00Uc7zkp0zTXXxFNPPRXPPPNMjBgxovP24cOHR3t7e+zYsaPL/R1bPZMA7EGqqqrijDPOiKVLl3be1tHREUuXLo2JEyeWuIwD8dZbb8Vrr70WdXV1ZU9hPxobG2P48OFdjrPW1tZ4/vnnHWe9wN///vd48803HWclKIoirrnmmli8eHH84Q9/iMbGxi4fP+OMM+LQQw/tcmytXbs2Nm7c6NjqgbwE3MM0NzfHjBkz4swzz4zx48fH/PnzY/fu3TFz5syyp/EfvvOd78TUqVNj1KhRsXnz5pg7d24MGDAgvva1r5U9Lb233nqryxmiDRs2xMsvvxxDhgyJkSNHxqxZs+LWW2+NE088MRobG2POnDlRX18f06ZNK290Uvt7roYMGRLz5s2LSy65JIYPHx6vvfZa3HDDDfHJT34yJk+eXOLqnJqamuKhhx6KJ598Mmpqajrf11dbWxuDBg2K2trauOKKK6K5uTmGDBkSgwcPjmuvvTYmTpwYn/3sZ0tez4eU/W3IfNg999xTjBw5sqiqqirGjx9fPPfcc2VPYi8uvfTSoq6urqiqqiqOPfbY4tJLLy3Wr19f9iyKonjmmWeKiPjQZcaMGUVRvPdPwcyZM6cYNmxYUV1dXZx33nnF2rVryx2d1P6eq7fffrs4//zzi2OOOaY49NBDi1GjRhVXXnllsWXLlrJnp7S35ykiinvvvbfzPv/+97+Lq6++ujjyyCOLww47rPjyl79cvPHGG+WNZp/6FUVRdH92AgBQFu8BBABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACAZAQgAkIwABABIRgACACQjAAEAkhGAAADJCEAAgGQEIABAMgIQACCZ/wOuMbWEJ2dbUAAAAABJRU5ErkJggg=="}),Object(l.jsx)("div",{className:"space",children:"To maximize my chances of getting the best result, for each round, I randomly removed upto 4 items and ran my algorithm and chose the highest count. To clear all ten rounds, I scripted it till I got lucky (usually happens in about 5 minute or so). Also, if you start packing vertically (we started horizontally), you might get better results, so you might want to try that as well. Here's the full script."}),Object(l.jsx)(p,{children:"from pwn import remote\nfrom time import time\nfrom random import sample\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Rectangle\n\ndebug = False\n\ndef fit(box, dims, dir='h', offset=(0, 0)):\n    fits = []\n    box_l, box_w = box\n\n    for dim in dims:\n        if dir == 'h':\n            idx = 0\n        else:\n            idx = 1\n\n        fitted = 0\n        results = []\n        offset_ = offset # Copy of offset for each candidate\n\n        multiplier = box[idx] // dim[idx]\n\n        # Cut is longer (resp. wider) than box\n        if multiplier == 0:\n            continue\n\n        # Cut is wider (resp. longer) than box\n        if dim[idx ^ 1] > box[idx ^ 1]:\n            continue\n\n        remainder = box[idx] % dim[idx]\n        candidates = []\n\n        # Try optimize remainder\n        if remainder != 0:\n            for i in range(1, multiplier + 1):\n                elements = [(i, dim)]\n                aggregate = i * dim[idx]\n\n                sorted_dims = sorted(dims, key=lambda a: a[idx], reverse=True)\n                \n                for inner_dim in sorted_dims:\n                    # Ignore self\n                    if inner_dim == dim:\n                        continue\n                    # Cut too wide (resp. long)\n                    if inner_dim[idx ^ 1] > box[idx ^ 1]:\n                        continue\n\n                    remaining_dimension = box[idx] - aggregate\n                        \n                    # If this new cut can be fit into the remaining area\n                    if inner_dim[idx] <= remaining_dimension:\n                        # Calculate how many of these cuts we can fit in here\n                        element_multiplier = remaining_dimension // inner_dim[idx]\n                        aggregate += element_multiplier * inner_dim[idx]\n                          \n                        elements.append((element_multiplier, inner_dim))\n\n                new_remainder = box[idx] % aggregate\n\n                if new_remainder <= remainder:\n                    remainder = new_remainder\n                    # cands.append(arr)\n                    candidates = elements\n\n        else:\n            candidates = [(multiplier, dim)]\n\n        for candidate in candidates:\n            element_multiplier = candidate[0]\n            candidate_l, candidate_h = candidate[1]\n\n            for a in range(element_multiplier):\n                if dir == 'h':\n                    results.append(((offset_[0] + a * candidate_l, offset_[1]),\n                                    candidate[1]))\n                else:\n                    results.append(((offset_[0], offset_[1] + a * candidate_h),\n                                    candidate[1]))\n\n            fitted += candidate_l * candidate_h * element_multiplier\n                \n            if dir == 'h':\n                new_box = (candidate_l * element_multiplier,\n                           box_w - candidate_h)\n            else:\n                new_box = (box_l - candidate_l,\n                           candidate_h * element_multiplier)\n            \n            # Check if inner box is not empty \n            if new_box[idx ^ 1] != 0:\n                # If it isn't, start filling in other direction\n                if dir == 'h':\n                    new_results, new_fitted = fit(\n                        new_box,\n                        dims,\n                        dir='v',\n                        offset=(offset_[0], offset_[1] + candidate_h)\n                )\n                else:\n                    new_results, new_fitted = fit(\n                        new_box,\n                        dims,\n                        dir='h',\n                        offset=(offset_[0] + candidate_l, offset_[1])\n                    )\n\n                fitted += new_fitted\n                results += new_results\n\n            # Adjust offsets for plotting\n            if dir == 'h':\n                offset_ = (offset_[0] + candidate_l * element_multiplier,\n                           offset_[1])\n            else:\n                offset_ = (offset_[0],\n                           offset_[1] + candidate_h * element_multiplier)\n\n        fits.append((fitted, results))\n       \n    # Edge case\n    if len(fits) == 0:\n        return [], 0\n\n    sorted_fits = sorted(fits, key=lambda a: a[0], reverse=True)\n\n    return sorted_fits[0][1], sorted_fits[0][0]\n\ndef plot(data, rect, name='fig'):\n    fig, ax = plt.subplots()\n\n    ax.plot([1, 1],[1, 1],color='cyan')\n    ax.add_patch(Rectangle((0, 0), rect[0], rect[1], color='#CECECE'))\n\n    for x in data[0]:\n        ax.add_patch(Rectangle(x[0], x[1][0], x[1][1],\n                     facecolor='blue', edgecolor='black'))\n\n    plt.savefig(name + '.png')\n\ntest_data = [\n  ((70, 50),\n  [(40, 7), (9, 20), (54, 49), (24, 37), (65, 22)]),\n  ((200, 200),\n  [(71, 17), (86, 88), (22, 86), (3, 63), (50, 40)]),\n  ((70, 50),\n  [(66, 12), (41, 17), (16, 22), (12, 17), (16, 18)]),\n  ((100, 100),\n  [(93, 28), (20, 7), (6, 9), (44, 74), (4, 74)]),\n  ((100, 100),\n  [(6, 63), (98, 40), (69, 89), (69, 9)]),\n  ((21, 11),\n  [(5, 9), (4, 4), (14, 2), (3, 2)]),\n  ((4, 10),\n  [(2, 6), (3, 6), (2, 2)]),\n  ((70, 50),\n  [(20, 38), (56, 12), (29, 33), (54, 28), (32, 34)]),\n  ((21, 11),\n  [(5, 7), (6, 11), (13, 8), (2, 8)]),\n  ((21, 11),\n  [(15, 3), (3, 7), (2, 5), (10, 3)])\n]\n\nif debug:\n    for i, ((l, w), dims) in enumerate(test_data):\n        fitted_h = fit((l, w), list(dims))\n        fitted_v = fit((l, w), list(dims), dir='v')\n\n        plot(fitted_h, (l, w), name=f'test_data_h_{i}')\n        plot(fitted_v, (l, w), name=f'test_data_v_{i}')\n\nwhile True:\n    p1 = remote('lunch-with-the-cia.hsc.tf', 1337)\n\n    for _ in range(3): print(p1.recvline())\n\n    try:\n        for i in range(10):\n            print(p1.recvline())\n       \n            l, w, k = map(int, p1.recvline().strip().split())\n\n            dims = []\n\n            for _ in range(k):\n                a, b = map(int, p1.recvline().strip().split())\n                dims.append((a, b))\n\n            if debug:\n                print(f'l: {l} w: {w} k: {k}')\n                print(dims)\n\n            fits = [\n                fit((l, w), dims)[1],\n                fit((l, w), dims, dir='v')[1]\n            ]\n\n            start = time()\n\n            for j in range(20):\n                # Algorithm too slow\n                if time() - start >= 10:\n                    break\n               \n                # print(f'{j}')\n\n                # Randomly remove one to five elements to improve chances\n                for k in range(1, 5):\n                    dims2 = sample(dims, max(len(dims) - i, 1))\n                    fits.append(fit((l, w), dims2)[1])\n                    fits.append(fit((l, w), dims2, dir='v')[1])\n                \n            waste = l * w - max(fits)\n\n            print(f'Round: {i}... Waste {waste}')\n\n            p1.sendline(str(waste))\n            print(p1.recvline())\n\n        print(p1.recvline())\n        break\n    except:\n        # EOF\n        pass"})]})})}}]),n}(a.Component)),y=function(A){Object(s.a)(n,A);var e=Object(r.a)(n);function n(){return Object(t.a)(this,n),e.apply(this,arguments)}return Object(i.a)(n,[{key:"render",value:function(){return Object(l.jsx)("div",{className:"main",children:Object(l.jsxs)("div",{className:"content",children:[Object(l.jsxs)("div",{children:[Object(l.jsx)("b",{children:"Description. "}),"We're given a script that simply loads a pickle, prompts for a flag, and then outputs either 'Nope!' or 'Correct!'."]}),Object(l.jsx)(p,{children:"ubuntu@ubuntu1604:~/Documents/ctf/redpwn/2021/pick2$ python3.8 ./chall.py \nWhat is the flag? foo\nNope!"}),Object(l.jsxs)("div",{className:"space",children:["The most straightforward way to inspect pickles is by using the the ",Object(l.jsx)("span",{class:"code-block",children:"dis"})," fuction from the ",Object(l.jsx)("span",{class:"code-block",children:"pickletools"})," module. We can then read the source, ",Object(l.jsx)("span",{class:"code-block",children:"eval"})," the relevant portion as bytes, and pass it to ",Object(l.jsx)("span",{class:"code-block",children:"dis"}),"."]}),Object(l.jsx)(p,{children:"from pickle import loads\nfrom pickletools import dis\n\nfil = open('chall.py', 'rb')\npickle = eval(fil.read()[27:-1])\nfil.close()\n\ndis(pickle)"}),Object(l.jsxs)("div",{className:"space",children:["For this challenge, we'll need to know a bit about pickle's bytecode spec. I'll try to explain as much as possible along the way, but if you need a more detailed explanation about the pickle VM, have a look ",Object(l.jsx)("a",{href:"https://checkoway.net/musings/pickle/",children:"here"}),", ",Object(l.jsx)("a",{href:"https://intoli.com/blog/dangerous-pickles/",children:"here"}),", and ",Object(l.jsx)("a",{href:"https://adrianstoll.com/computer-insecurity/python-in-a-pickle.html",children:"here"}),". Anyways, here's a part of ",Object(l.jsx)("span",{class:"code-block",children:"dis"}),"'s output:"]}),Object(l.jsx)(p,{children:"     0: (        MARK\n     1: I        INT        128\n     6: I        INT        4\n     9: I        INT        99\n    13: I        INT        112\n\n............................................\n............................................\n............................................\n............................................\n\n544256: I        INT        82\n544260: I        INT        133\n544265: I        INT        82\n544269: I        INT        46\n544273: t        TUPLE      (MARK at 0)\n544274: p        PUT        69420\n544281: c        GLOBAL     'pickle loads'\n544295: c        GLOBAL     'builtins bytes'\n544311: g        GET        69420\n544318: \\x85     TUPLE1\n544319: R        REDUCE\n544320: \\x85     TUPLE1\n544321: R        REDUCE\n544322: .        STOP"}),Object(l.jsxs)("div",{className:"space",children:["The first column is for the memory address, the second (with the single byte) is for the opcode, the third is for the mnemonic, and the fourth is for the payload. At the address ",Object(l.jsx)("span",{class:"code-block",children:"0"}),", a ",Object(l.jsx)("span",{class:"code-block",children:"MARK"})," is placed, and then every instruction until the address ",Object(l.jsx)("span",{class:"code-block",children:"544269"})," pushes a single byte on the stack one at a time. The next two instructions create a tuple out of these bytes and place this tuple into the memo at the address ",Object(l.jsx)("span",{class:"code-block",children:"69420"}),". The instructions starting at ",Object(l.jsx)("span",{class:"code-block",children:"544311"})," pick up this tuple from the memo, reduce it once (so that ",Object(l.jsx)("span",{class:"code-block",children:"bytes"})," is called on it), then reduce it again (so that ",Object(l.jsx)("span",{class:"code-block",children:"pickle.loads"})," is called on it). Basically, all that's happened so far is something like ",Object(l.jsx)("span",{class:"code-block",children:"loads(bytes([128, 4, ..., 46]))"}),". In other words, this is just an unpacker that loads another pickle, and we need to disassemble this nested pickle."]}),Object(l.jsxs)("div",{className:"space",children:["Now, the problem is that ",Object(l.jsx)("span",{class:"code-block",children:"dis"})," writes to stdout, so there's no way for us to work with its output at runtime. As a quick workaround, we can write ",Object(l.jsx)("span",{class:"code-block",children:"dis"}),"'s output to a file and then read from the file."]}),Object(l.jsx)(p,{children:"from pwn import process\n\ndef parse():\n    p1 = process(['python3', '-m', 'pickletools', 'tmp'])\n\n    o = []\n\n    while True:\n        try:\n            o.append(p1.recvline())\n        except:\n            break\n\n    p1.close()\n\n    return o\n\ndef put(x):\n    tt = open('tmp', 'wb')\n    tt.write(x)\n    tt.close()\n\nput(pickle)\nnested_pickle = parse()[1:-21]\nnested_pickle = bytes([int(a.split()[-1]) for a in nested_pickle])\n\ndis(nested_pickle)"}),Object(l.jsx)("div",{className:"space",children:"Here's the output:"}),Object(l.jsx)(p,{children:"119451: \\x8c     SHORT_BINUNICODE 'pickledgreekoregano'\n119472: \\x8c     SHORT_BINUNICODE '\\nI'\n119476: \\x8c     SHORT_BINUNICODE 'pickledpupunha'\n119492: \\x8c     SHORT_BINUNICODE 'Nope!'\n119499: \\x8c     SHORT_BINUNICODE 'Correct!'\n119509: \\x86     TUPLE2\n119510: \\x8c     SHORT_BINUNICODE 'pickledximenia'\n119526: c        GLOBAL           'builtins input'\n119542: \\x8c     SHORT_BINUNICODE 'What is the flag? '\n119562: \\x85     TUPLE1\n119563: R        REDUCE\n119564: \\x8c     SHORT_BINUNICODE 'pickledgarlic'\n119579: \\x8c     SHORT_BINUNICODE 'pickledcorneliancherry'\n119603: \\x8c     SHORT_BINUNICODE 'pickledboysenberry'\n119623: \\x86     TUPLE2\n119624: d        DICT             (MARK at 13)\n119625: b        BUILD\n119626: (        MARK\n119627: \\x8c     SHORT_BINUNICODE 'pickledburmesegrape'\n119648: c        GLOBAL           'io pickledximenia.__len__'\n119675: )        EMPTY_TUPLE\n119676: R        REDUCE\n119677: \\x8c     SHORT_BINUNICODE 'pickledximenia'\n119693: c        GLOBAL           'io pickledximenia.encode'\n119719: )        EMPTY_TUPLE\n119720: R        REDUCE\n119721: d        DICT             (MARK at 119626)\n119722: b        BUILD\n119723: c        GLOBAL           'builtins print'\n119739: c        GLOBAL           'io pickledpupunha.__getitem__'\n119770: c        GLOBAL           'pickle loads'\n119784: \\x8c     SHORT_BINUNICODE 'io'\n119788: c        GLOBAL           'io pickledgarlic.__getitem__'\n119818: c        GLOBAL           'io pickledburmesegrape.__eq__'\n119849: I        INT              64\n119853: \\x85     TUPLE1\n119854: R        REDUCE\n119855: \\x85     TUPLE1\n119856: R        REDUCE\n119857: \\x93     STACK_GLOBAL\n119858: \\x85     TUPLE1\n119859: R        REDUCE\n119860: \\x85     TUPLE1\n119861: R        REDUCE\n119862: \\x85     TUPLE1\n119863: R        REDUCE\n119864: .        STOP"}),Object(l.jsx)("div",{className:"space",children:"The bytecode looks like its working with a bunch of pickle-themed variables. However, we cannot inspect these variables because it hasn't been loaded into memory yet (so far we've merely disassembled pickle). To actually run it, we need to load the pickle."}),Object(l.jsx)(p,{children:"loads(nested_pickle)\nWhat is the flag? foo\nNope!\nfrom io import pickledburmesegrape\npickledburmesegrape\n4"}),Object(l.jsxs)("div",{className:"space",children:["If you poke around a bit, you should be able to explore most of the bytecode via the shell itself. Here are the highlights: The input's  length (",Object(l.jsx)("span",{class:"code-block",children:"pickledburmesegrape"}),") is verified to be 64 (addresses ",Object(l.jsx)("span",{className:"code-block",children:"119818"})," to ",Object(l.jsx)("span",{className:"code-block",children:"119853"}),"), and if it is, the first item of the dictionary ",Object(l.jsx)("span",{className:"code-block",children:"pickledgarlic"})," is loaded. This item turns out to be the variable ",Object(l.jsx)("span",{className:"code-block",children:"pickledboysenberry"})," (Line ",Object(l.jsx)("span",{className:"code-block",children:"119603"}),"). Of course, our input (foo) was only 4 bytes long (including the new line), so let's retry the whole thing and this time pass a 64 byte string starting with 'flag' and then inspect ",Object(l.jsx)("span",{class:"code-block",children:"pickledboysenberry"}),"."]}),Object(l.jsx)(p,{children:"loads(nested_pickle)\nWhat is the flag? flag{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\nNope!\nfrom io import pickledboysenberry\nloads(pickledboysenberry)\n0\ndis(pickledboysenberry)"}),Object(l.jsx)("div",{className:"space",children:"Here's the tail:"}),Object(l.jsx)(p,{children:"118689: \\x85     TUPLE1\n118690: R        REDUCE\n118691: d        DICT       (MARK at 20992)\n118692: b        BUILD\n118693: c        GLOBAL     'pickle loads'\n118707: c        GLOBAL     'io pickledcedarbaycherry'\n118733: \\x85     TUPLE1\n118734: R        REDUCE\n118735: .        STOP"}),Object(l.jsx)("div",{className:"space",children:"Digging into the more pickles, we finally reach this one:"}),Object(l.jsx)(p,{children:"from io import pickledcedarbaycherry\ndis(pickledcedarbaycherry)\nfrom io import pickledhuito\ndis(pickledhuito)"}),Object(l.jsx)("div",{className:"space",children:"Here's its dissasembly:"}),Object(l.jsx)(p,{children:"    0: \\x80 PROTO      4\n    2: I    INT        102\n    7: I    INT        108\n   12: I    INT        97\n   16: I    INT        103\n   21: I    INT        123\n   26: I    INT        97\n   30: I    INT        97\n   34: I    INT        97\n   38: I    INT        97\n   42: I    INT        97\n   46: I    INT        97\n   50: I    INT        97\n   54: I    INT        97\n   58: I    INT        97\n   62: I    INT        97\n   66: I    INT        97\n   70: I    INT        97\n   74: I    INT        97\n   78: I    INT        97\n   82: I    INT        97\n   86: I    INT        97\n   90: I    INT        97\n   94: I    INT        97\n   98: I    INT        97\n  102: I    INT        97\n  106: I    INT        97\n  110: I    INT        97\n  114: I    INT        97\n  118: I    INT        97\n  122: I    INT        97\n  126: I    INT        97\n  130: I    INT        97\n  134: I    INT        97\n  138: I    INT        97\n  142: I    INT        97\n  146: I    INT        97\n  150: I    INT        97\n  154: I    INT        97\n  158: I    INT        97\n  162: I    INT        97\n  166: I    INT        97\n  170: I    INT        97\n  174: I    INT        97\n  178: I    INT        97\n  182: I    INT        97\n  186: I    INT        97\n  190: I    INT        97\n  194: I    INT        97\n  198: I    INT        97\n  202: I    INT        97\n  206: I    INT        97\n  210: I    INT        97\n  214: I    INT        97\n  218: I    INT        97\n  222: I    INT        97\n  226: I    INT        97\n  230: I    INT        97\n  234: I    INT        97\n  238: I    INT        97\n  242: I    INT        97\n  246: I    INT        97\n  250: I    INT        97\n  254: I    INT        97\n  258: I    INT        97\n  262: I    INT        10\n  266: 0    POP\n  267: 0    POP\n  268: 0    POP\n  269: 0    POP\n  270: 0    POP\n  271: 0    POP\n  272: 0    POP\n  273: 0    POP\n  274: 0    POP\n  275: 0    POP\n  276: 0    POP\n  277: 0    POP\n  278: 0    POP\n  279: 0    POP\n  280: 0    POP\n  281: 0    POP\n  282: 0    POP\n  283: 0    POP\n  284: 0    POP\n  285: 0    POP\n  286: 0    POP\n  287: 0    POP\n  288: 0    POP\n  289: 0    POP\n  290: 0    POP\n  291: 0    POP\n  292: 0    POP\n  293: 0    POP\n  294: 0    POP\n  295: 0    POP\n  296: 0    POP\n  297: 0    POP\n  298: 0    POP\n  299: 0    POP\n  300: 0    POP\n  301: 0    POP\n  302: 0    POP\n  303: 0    POP\n  304: 0    POP\n  305: 0    POP\n  306: 0    POP\n  307: 0    POP\n  308: 0    POP\n  309: 0    POP\n  310: 0    POP\n  311: 0    POP\n  312: 0    POP\n  313: 0    POP\n  314: 0    POP\n  315: 0    POP\n  316: 0    POP\n  317: 0    POP\n  318: 0    POP\n  319: 0    POP\n  320: 0    POP\n  321: 0    POP\n  322: 0    POP\n  323: 0    POP\n  324: 0    POP\n  325: 0    POP\n  326: 0    POP\n  327: 0    POP\n  328: 0    POP\n  329: p    PUT        0\n  332: 0    POP\n  333: c        GLOBAL           'pickle io'\n  344: (        MARK\n  345: \\x8c     SHORT_BINUNICODE 'pickledmacadamia'\n  363: g        GET              0\n  366: \\x8c     SHORT_BINUNICODE 'pickledbarberry'\n  383: I        INT              102\n  388: \\x8c     SHORT_BINUNICODE 'pickledgarlic'\n  403: \\x8c     SHORT_BINUNICODE 'pickledcorneliancherry'\n  427: \\x8c     SHORT_BINUNICODE 'pickledbluetongue'\n  446: \\x86     TUPLE2\n  447: d        DICT             (MARK at 344)\n  448: b    \tBUILD\n  449: c    \tGLOBAL           'pickle loads'\n  463: \\x8c \tSHORT_BINUNICODE 'io'\n  467: c    \tGLOBAL           'io pickledgarlic.__getitem__'\n  497: c    \tGLOBAL           'pickle loads'\n  511: c    \tGLOBAL           'io pickledcrabapple'\n  532: \\x85 \tTUPLE1\n  533: R        REDUCE\n  534: \\x85     TUPLE1\n  535: R        REDUCE\n  536: \\x93     STACK_GLOBAL\n  537: \\x85     TUPLE1\n  538: R        REDUCE\n  539: .        STOP"}),Object(l.jsxs)("div",{className:"space",children:["Lines ",Object(l.jsx)("span",{class:"code-block",children:"2"})," to ",Object(l.jsx)("span",{class:"code-block",children:"262"})," push our input on the stack, while the following instructions pop them one by one until it reaches instruction ",Object(l.jsx)("span",{class:"code-block",children:"332"}),", which pushes, in this case, the first character of our input, 'f' on the memo. Next, ",Object(l.jsx)("span",{class:"code-block",children:"pickledmacadamia"})," is set to this memo variable (line ",Object(l.jsx)("span",{class:"code-block",children:"363"}),"), ",Object(l.jsx)("span",{class:"code-block",children:"pickledbarberry"})," is set to 102 (line ",Object(l.jsx)("span",{class:"code-block",children:"383"}),") and ",Object(l.jsx)("span",{class:"code-block",children:"pickledcrabapple"})," is loaded and invoked. If it succeeds, ",Object(l.jsx)("span",{class:"code-block",children:"pickledbluetongue"})," is loaded (presumably to check the second character), and if it fails, the first item of the dictionary is picked (and leads back to the ",Object(l.jsx)("span",{class:"code-block",children:"print('Nope')"}),"). This is just one check in the link; In all, there would be a huge link of checks and if any one of them fails, the whole thing fails. Let's look at the disassembly of the first check, ",Object(l.jsx)("span",{class:"code-block",children:"pickledcrabapple"}),":"]}),Object(l.jsx)(p,{children:"    0: \\x80 PROTO      4\n    2: c    GLOBAL     'pickle io'\n   13: c    GLOBAL     'io pickledmacadamia.__eq__'\n   41: c    GLOBAL     'io pickledbarberry'\n   61: \\x85 TUPLE1\n   62: R    REDUCE\n   63: .    STOP"}),Object(l.jsxs)("div",{className:"space",children:["Pretty simple: All it does is check whether ",Object(l.jsx)("span",{class:"code-block",children:"pickledmacadamia"})," and ",Object(l.jsx)("span",{class:"code-block",children:"pickledbarberry"})," are equal. In this case, it checks that the first character of our input is the byte 102 ('f'). If you follow the trail of pickles, you'll see that the first four checks basically check for the characters f, l, a, and g. However, the remaining checks are not this straightforward. For example, the check for the fifth character, ",Object(l.jsx)("span",{class:"code-block",children:"pickledvoavanga"}),", is slightly different:"]}),Object(l.jsx)(p,{children:"    0: \\x80 PROTO      4\n    2: I    INT        102\n    7: I    INT        108\n   12: I    INT        97\n   16: I    INT        103\n   21: I    INT        123\n   26: I    INT        97\n   30: I    INT        97\n   34: I    INT        97\n   38: I    INT        97\n   42: I    INT        97\n   46: I    INT        97\n   50: I    INT        97\n   54: I    INT        97\n   58: I    INT        97\n   62: I    INT        97\n   66: I    INT        97\n   70: I    INT        97\n   74: I    INT        97\n   78: I    INT        97\n   82: I    INT        97\n   86: I    INT        97\n   90: I    INT        97\n   94: I    INT        97\n   98: I    INT        97\n  102: I    INT        97\n  106: I    INT        97\n  110: I    INT        97\n  114: I    INT        97\n  118: I    INT        97\n  122: I    INT        97\n  126: I    INT        97\n  130: I    INT        97\n  134: I    INT        97\n  138: I    INT        97\n  142: I    INT        97\n  146: I    INT        97\n  150: I    INT        97\n  154: I    INT        97\n  158: I    INT        97\n  162: I    INT        97\n  166: I    INT        97\n  170: I    INT        97\n  174: I    INT        97\n  178: I    INT        97\n  182: I    INT        97\n  186: I    INT        97\n  190: I    INT        97\n  194: I    INT        97\n  198: I    INT        97\n  202: I    INT        97\n  206: I    INT        97\n  210: I    INT        97\n  214: I    INT        97\n  218: I    INT        97\n  222: I    INT        97\n  226: I    INT        97\n  230: I    INT        97\n  234: I    INT        97\n  238: I    INT        97\n  242: I    INT        97\n  246: I    INT        97\n  250: I    INT        97\n  254: I    INT        97\n  258: I    INT        97\n  262: I    INT        10\n  266: 0    POP\n  267: 0    POP\n  268: 0    POP\n  269: 0    POP\n  270: 0    POP\n  271: 0    POP\n  272: 0    POP\n  273: 0    POP\n  274: 0    POP\n  275: p    PUT        1\n  278: 0    POP\n  279: 0    POP\n  280: 0    POP\n  281: 0    POP\n  282: 0    POP\n  283: 0    POP\n  284: 0    POP\n  285: 0    POP\n  286: 0    POP\n  287: 0    POP\n  288: 0    POP\n  289: 0    POP\n  290: 0    POP\n  291: 0    POP\n  292: 0    POP\n  293: 0    POP\n  294: 0    POP\n  295: 0    POP\n  296: 0    POP\n  297: 0    POP\n  298: 0    POP\n  299: 0    POP\n  300: 0    POP\n  301: 0    POP\n  302: 0    POP\n  303: 0    POP\n  304: 0    POP\n  305: 0    POP\n  306: 0    POP\n  307: 0    POP\n  308: 0    POP\n  309: 0    POP\n  310: 0    POP\n  311: 0    POP\n  312: 0    POP\n  313: 0    POP\n  314: 0    POP\n  315: 0    POP\n  316: 0    POP\n  317: 0    POP\n  318: 0    POP\n  319: 0    POP\n  320: 0    POP\n  321: 0    POP\n  322: 0    POP\n  323: 0    POP\n  324: 0    POP\n  325: 0    POP\n  326: 0    POP\n  327: 0    POP\n  328: p    PUT        0\n  331: 0    POP\n  332: 0    POP\n  333: 0    POP\n  334: 0    POP\n  335: 0    POP\n  336: c    GLOBAL     'pickle io'\n  347: (    MARK\n  348: \\x8c     SHORT_BINUNICODE 'pickledmacadamia'\n  366: g        GET        0\n  369: \\x8c     SHORT_BINUNICODE 'pickledbarberry'\n  386: g        GET        1\n  389: \\x8c     SHORT_BINUNICODE 'pickledgarlic'\n  404: \\x8c     SHORT_BINUNICODE 'pickledcorneliancherry'\n  428: \\x8c     SHORT_BINUNICODE 'pickledarugula'\n  444: \\x86     TUPLE2\n  445: d        DICT       (MARK at 347)\n  446: b    BUILD\n  447: c    GLOBAL     'pickle loads'\n  461: \\x8c SHORT_BINUNICODE 'io'\n  465: c    GLOBAL     'io pickledgarlic.__getitem__'\n  495: c    GLOBAL     'pickle loads'\n  509: c    GLOBAL     'io pickledeasternmayhawthorn'\n  539: \\x85 TUPLE1\n  540: R    REDUCE\n  541: \\x85 TUPLE1\n  542: R    REDUCE\n  543: \\x93 STACK_GLOBAL\n  544: \\x85 TUPLE1\n  545: R    REDUCE\n  546: .    STOP"}),Object(l.jsxs)("div",{children:["Very similar, except that line ",Object(l.jsx)("span",{class:"code-block",children:"386"})," now sets ",Object(l.jsx)("span",{class:"code-block",children:"pickledbarberry"})," to a character in our input (which was put on the memo at line ",Object(l.jsx)("span",{className:"code-block",children:"275"}),") instead of a hardcoded value. Moreover, the check (",Object(l.jsx)("span",{class:"code-block",children:"pickledeasternmayhawthorn"}),") isn't a simple equality, but a greater than or equal to operator. In other words, it tells us whether the fifth character in our input is greater than or equal to some nth character in our input. Not very helpful. After a while of searching, I found three checks which ",Object(l.jsx)("i",{children:"do"})," help:"]}),Object(l.jsx)(p,{children:"from io import pickledcoconut\nfrom io import pickledhorseradish\nfrom io import pickledlychee\n\ndis(pickledcoconut)\n    0: \\x80 PROTO      4\n    2: c    GLOBAL     'pickle io'\n   13: c    GLOBAL     'io pickledmacadamia.__sub__'\n   42: c    GLOBAL     'io pickledbarberry'\n   62: \\x85 TUPLE1\n   63: R    REDUCE\n   64: .    STOP\n\ndis(pickledhorseradish)\n    0: \\x80 PROTO      4\n    2: c    GLOBAL     'pickle io'\n   13: c    GLOBAL     'io pickledmacadamia.__add__'\n   42: c    GLOBAL     'io pickledbarberry'\n   62: \\x85 TUPLE1\n   63: R    REDUCE\n   64: .    STOP\n\ndis(pickledlychee)\n    0: \\x80 PROTO      4\n    2: c    GLOBAL     'pickle io'\n   13: c    GLOBAL     'io pickledmacadamia.__xor__'\n   42: c    GLOBAL     'io pickledbarberry'\n   62: \\x85 TUPLE1\n   63: R    REDUCE\n   64: .    STOP"}),Object(l.jsxs)("div",{children:["These three checks return the sum, difference, or xor of two characters at positions ",Object(l.jsx)("span",{class:"code-block",children:"m"})," and ",Object(l.jsx)("span",{class:"code-block",children:"n"}),". This means that if by some chance ",Object(l.jsx)("span",{class:"code-block",children:"m"})," happens to be 0, 1, 2, 3, or 4 (characters we know), then we can undo the operation to recover the character at position ",Object(l.jsx)("span",{class:"code-block",children:"n"}),". To be more concrete, let's say we come across a pickle that checks whether the xor of the 1st character and the 41st character is 90. Because xor is reversible, this immediately reveals that the 41st character is the the xor of the first character and 90. We can then add this newly discovered character to our list of known characters and then keep looking for more checks that recover other characters."]}),Object(l.jsxs)("div",{className:"space",children:["Obviously, going through each check manually is tedious, so we need some way to parse the bytecode into an AST of some sort. There's a library called ",Object(l.jsx)("a",{href:"https://github.com/trailofbits/fickling",children:"fickling"})," that does just this, but unfortunately it doesn't support the ",Object(l.jsx)("span",{class:"code-block",children:"DICT"})," opcode at the moment. Thankfully, it isn't that hard to write an ad-hoc parser from scratch (especially considering that we only need to extract a few details). Specifically, we'll need to extract the character indices that are being checked, the expected result of the check, the current check, and the next check. For example, if it checks that characters 4 and 47 sum to 218, then we'll need to extract the values 4, 47, sum, and 218 (in addition to the next check in the link). Once we have this, we can reverse the operation to recover the character at index 47, and can repeat these steps for the next check. Finally, all we need to do is run this forever until we've recovered all 64 characters. Here's the full script (",Object(l.jsxs)("span",{class:"code-block",children:["python3.8 -c \"print('flag","{","' + 'a' * 64)\" | python3.8 ./solve.py"]}),")."]}),Object(l.jsx)(p,{children:"from pdb import set_trace\nfrom pickle import loads\nfrom pickletools import dis\nfrom pwn import process\nimport sys\n\nknown = ['f', 'l', 'a', 'g', '{'] + [None] * 59\n\ndef undo_add(a, s):\n    return s - a\n\ndef undo_xor(a, x):\n    return a ^ x\n\ndef undo_sub(a, b, s):\n    if a:\n        return a - s\n    else:\n        return b + s\n\ndef undo_op(idx1, idx2, result, condition):\n    if idx1 < 0 or idx2 < 0 or condition not in [b'pickledhorseradish',\n                                                 b'pickledlychee',\n                                                 b'pickledcoconut']:\n        return\n\n    if known[idx1] or known[idx2]:\n        if known[idx1]:\n            a = ord(known[idx1])\n        else:\n            a = ord(known[idx2])\n        if condition == b'pickledhorseradish':\n            b = undo_add(a, result)\n        if condition == b'pickledlychee':\n            b = undo_xor(a, result)\n        if condition == b'pickledcrabapple':\n            b = a\n        if condition == b'pickledcoconut':\n            if known[idx1]:\n                b = undo_sub(a, None, result)\n            else:\n                b = undo_sub(None, a, result)\n\n        if known[idx1]:\n            known[idx2] = chr(b)\n        else:\n            known[idx1] = chr(b)\n\ndef parse(c1_lim=5):\n    p1 = process(['python3', '-m', 'pickletools', 'tmp'])\n\n    c1 = 0\n    c2 = 0\n    searching_for_cond = False\n    idx = 63\n    idx1 = -1\n    idx2 = -1\n\n    while True:\n        try:\n            line = p1.recvline().split()\n            data = [a.strip() for a in line]\n            \n            # PUSH\n            if data[1] == b'0':\n                idx -= 1\n\n            # find target indices\n            if data[1] == b'p':\n                if data[3] == b'0':\n                    if idx1 == -1:\n                        idx1 = idx\n                elif data[3] == b'1':\n                    if idx2 == -1:\n                        idx2 = idx\n\n            # find next check\n            if data[1] == b'\\x8c':\n                c1 += 1\n                if c1 == c1_lim:\n                    nxt = data[3][1:-1]\n\n            if searching_for_cond:\n                c2 += 1\n\n            if data[-1][:5] == b'loads':\n                searching_for_cond = True\n            \n            # find the type of check and the result\n            if searching_for_cond:\n                if c2 == 4:\n                    # sometimes MARK shows up unexpectedly, ignore\n                    if data[-1] == b'MARK':\n                        c2 = 1\n                        continue\n                    condition = data[-1][:-1]\n                \n                if c2 == 8:\n                    result = data[-1]\n                    try:\n                        result = int(result)\n                    except:\n                        pass\n            \n        except:\n            break\n\n    p1.close()\n    undo_op(idx1, idx2, result, condition)\n\n    return nxt\n\ndef put(x):\n    tt = open('tmp', 'wb')\n    tt.write(x)\n    tt.close()\n\nfil = open('chall.py', 'rb')\npickle = eval(fil.read()[27:-1])\n\nloads(pickle)\n\nfrom io import pickledgarlic\n\nexec('from io import ' + pickledgarlic[1])\nmodule = eval(pickledgarlic[1])\n\nput(module)\nloads(module)\n\nfrom io import pickledcedarbaycherry\n\nput(pickledcedarbaycherry)\nnxt = parse(c1_lim=3)\nexec('from io import ' + nxt.decode())\nnxt = eval(nxt)\n\nfirst = nxt\n\nwhile True:\n    put(nxt)\n    \n    found = [a for a in known if a is not None]\n    if len(found) >= 64:\n        break\n\n    try:\n        nxt = parse()\n    except:\n        if len(found) < 64:\n            nxt = first\n            continue\n        else:\n            break\n\n    print(''.join(found))\n    exec('from io import ' + nxt.decode())\n    nxt = eval(nxt)\n\nprint(''.join(found))"})]})})}}]),n}(a.Component),X=function(A){Object(s.a)(n,A);var e=Object(r.a)(n);function n(){return Object(t.a)(this,n),e.apply(this,arguments)}return Object(i.a)(n,[{key:"render",value:function(){return Object(l.jsx)("div",{className:"main",children:Object(l.jsxs)("div",{className:"content",children:[Object(l.jsxs)("div",{children:[Object(l.jsx)("b",{children:"Description. "}),"We're given a script that runs input passed to it through Python's ",Object(l.jsx)("span",{className:"code-block",children:"string.replace"}),". The challenge is to prove that this setup is Turing complete."]}),Object(l.jsx)(p,{children:"#!/usr/local/bin/python\n\nfrom random import SystemRandom\nrand = SystemRandom()\n\n\ndef test_substitution(substitutions, string):\n    def substitute(s, a, b):\n        initial = s\n        s = s.replace(a, b)\n        return (s, not s == initial)\n\n    # s ^ 2 rounds for string of length s\n    for _ in range(len(string) ** 2):\n        performed_substitute = False\n        for find, replace in substitutions:\n            string, performed_substitute = substitute(string, find, replace)\n            # once a substitute is performed, go to next round\n            if performed_substitute:\n                break\n        # if no substitute was performed this round, we are done\n        if not performed_substitute:\n            break\n    return string\n\n\ndef read_substitution(string):\n    substitution = tuple(s.strip() for s in string.split('=>'))\n    return substitution if len(substitution) == 2 else ('', '')\n\n\ndef run_level(case_generator, max_subs, test_cases=32):\n    if input('See next level? (y/n) ') == 'n':\n        exit()\n\n    print('-' * 80)\n    print('Here is this level's intended behavior:')\n    for _ in range(10):\n        initial, target = case_generator()\n        print(f'\nInitial string: {initial}')\n        print(f'Target string: {target}')\n\n    print('-' * 80)\n    substitutions = []\n    current = input(\n        f'Enter substitution of form \"find => replace\", {max_subs} max: '\n    )\n    substitutions.append(read_substitution(current))\n    for _ in range(max_subs - 1):\n        if input('Add another? (y/n) ') == 'n':\n            break\n        current = input('Enter substitution of form \"find => replace\": ')\n        substitutions.append(read_substitution(current))\n\n    print('-' * 80)\n    print('Testing substitutions...', flush=True)\n    for _ in range(test_cases):\n        initial, target = case_generator()\n        output = test_substitution(substitutions, initial)\n        if not output == target:\n            print(f'Failed on string: {initial}.')\n            print(f'Expected: {target}.')\n            print(f'Computed: {output}.')\n            exit()\n    print('Level passed!')\n\n\nprint('''\nWelcome to The Substitution Game!\n\nIn each level, you will enter a list of string substitutions.\nFor example, you may want to change every instance of 'abcd' to 'def'.\n\nThe game will provide a series of test cases.\nFor each case, substitutions will be applied repeatedly in a series of rounds.\nIn each round, the first possible substitution will be performed.\nFor test case of length s, there will be s ^ 2 substitution rounds.\n\nIn each round, we will show examples of intended substitution behavior.\nIt is your goal to match our behavior.\n''')\n\n\nrandint = rand.randint\n\n\ndef level_1():\n    initial = f'{\"0\" * randint(0, 20)}initial{\"0\" * randint(0, 20)}'\n    target = initial.replace('initial', 'target')\n    return (initial, target)\n\n\ndef level_2():\n    initial = ''.join(\n        rand.choice(['hello', 'ginkoid']) for _ in range(randint(10, 20))\n    )\n    target = initial.replace('hello', 'goodbye').replace('ginkoid', 'ginky')\n    return (initial, target)\n\n\ndef level_3():\n    return ('a' * randint(10, 100), 'a')\n\n\ndef level_4():\n    return ('g' * randint(10, 100), 'ginkoid')\n\n\ndef level_5():\n    random_string = ''.join(\n        str(randint(0, 1)) for _ in range(randint(25, 50))\n    )\n    initial = random_string\n    initial += rand.choice(['', '0', '1'])\n    initial += random_string[::-1]\n\n    if rand.randint(0, 1):\n        return (f'^{initial}$', 'palindrome')\n    else:\n        shuffled = list(initial)\n        rand.shuffle(shuffled)\n        return (\n            f'^{\"\".join(shuffled)}$',\n            'not_palindrome'\n        )\n\n\ndef level_6():\n    first_number = randint(0, 255)\n    second_number = randint(0, 255)\n    answer = first_number + second_number\n    result = 'correct'\n    # random chance that answer is wrong\n    if rand.randint(0, 1):\n        answer = randint(0, 511)\n        if not answer == first_number + second_number:\n            result = 'incorrect'\n\n    # convert all to string representations\n    numbers = [\n        bin(first_number)[2:], bin(second_number)[2:], bin(answer)[2:]\n    ]\n\n    # chance to pad a number or answer\n    if randint(0, 1):\n        index = randint(0, 2)\n        numbers[index] = '0' * randint(1, 3) + numbers[index]\n        # chance to make padded number additionally wrong\n        if randint(0, 1):\n            result = 'incorrect'\n            numbers[index] = '1' + numbers[index]\n\n    return (f'^{numbers[0]}+{numbers[1]}={numbers[2]}$', result)\n\n\nrun_level(level_1, 5)\nrun_level(level_2, 10)\nrun_level(level_3, 10)\nrun_level(level_4, 10)\nrun_level(level_5, 100, test_cases=128)\nrun_level(level_6, 300, test_cases=128)\n\nprint('-' * 80)\nprint('You win! Here's your flag: [REDACTED]')"}),Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Level 1."})," It's easiest to see how this works by diving right in. In the first level, we're asked to change something like ",Object(l.jsx)("span",{className:"code-block",children:"0000000000initial00000000"})," to ",Object(l.jsx)("span",{className:"code-block",children:"0000000000target00000000"}),". Easy enough: A rule like ",Object(l.jsx)("span",{className:"code-block",children:"initial=>target"})," will do."]}),Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Level 2."})," Another easy level: Inputs strings like ",Object(l.jsx)("span",{className:"code-block",children:"helloginkoid"})," must become ",Object(l.jsx)("span",{className:"code-block",children:"goodbyeginky"}),", so this is basically just an extension of the previous level. The two rules ",Object(l.jsx)("span",{className:"code-block",children:"hello=>goodbye"})," and ",Object(l.jsx)("span",{className:"code-block",children:"ginkoid=>ginky"})," do the job."]}),Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Level 3."})," This time there's something new: Strings with the character ",Object(l.jsx)("span",{className:"code-block",children:"a"})," repeated an arbitrary number of times must become just the character ",Object(l.jsx)("span",{className:"code-block",children:"a"}),". The rule to do this (",Object(l.jsx)("span",{className:"code-block",children:"aa=>a"}),") is suriprisingly simple and gives us some insight about how the ",Object(l.jsx)("span",{className:"code-block",children:"test_substitution"})," function works. This function applies the same rule each round, so each time it does so, the length of the input string halves. So for a string of length ",Object(l.jsx)(j.a,{children:"n"}),", it only takes ",Object(l.jsx)(j.a,{children:"$\\log_2 n + 1$"})," rounds to reduce it to a single character. For example, this happens for an input like ",Object(l.jsx)("span",{className:"code-block",children:"aaaaaaaa"}),":"]}),Object(l.jsxs)("div",{className:"space box",children:["Round 1: \xa0 aaaaaaaa",Object(l.jsx)("br",{}),"Round 2: \xa0 aaaa",Object(l.jsx)("br",{}),"Round 3: \xa0 aa",Object(l.jsx)("br",{}),"Round 4: \xa0 a",Object(l.jsx)("br",{})]}),Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Level 4."})," Again very similar to level 3: Strings with the character ",Object(l.jsx)("span",{className:"code-block",children:"g"})," repeated an arbitrary number of times must become ",Object(l.jsx)("span",{className:"code-block",children:"ginkoid"}),". Using the same idea as we did in level 3, we can use the rule ",Object(l.jsx)("span",{className:"code-block",children:"ggg=>gg"})," to fold the input to ",Object(l.jsx)("span",{className:"code-block",children:"gg"}),". Then we can add a new rule ",Object(l.jsx)("span",{className:"code-block",children:"gg=>ginkoid"})," to turn the 2 ",Object(l.jsx)("span",{className:"code-block",children:"g"}),"s to ",Object(l.jsx)("span",{className:"code-block",children:"ginkoid"}),"."]}),Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Level 5."})," This is where things get challenging. In this level, palindromes must be detected and converted to the string ",Object(l.jsx)("span",{className:"code-block",children:"palindrome"}),", and all other strings must be converted to the string ",Object(l.jsx)("span",{className:"code-block",children:"not_palindrome"}),". Because ",Object(l.jsx)("span",{className:"code-block",children:"string.replace"})," only works with adjacent characters, it's not immediately obvious how to go about doing this. The most natural thing to do is to start detecting from the middle because (as I wrongly assumed) all palindromes reflect around the middle, and then verify that each character to the left and right of this middle section is the same. However, this approach does not work for many reasons. For starters, odd-length palindromes don't reflect around the middle, and detecting them requires more than the 100 substitution limit this level enforces."]}),Object(l.jsxs)("div",{className:"space",children:["The only way, then, is to verify that characters on either end of the string are the same. But for this, we would need to somehow bring the first character to the end to do the comparison. So here's a trick to do just that: First, I'm going to need some \"marker\" to decide which string I'm going to be working with. Let's say I chose ",Object(l.jsx)("span",{className:"code-block",children:"*"}),", and add the two substitutions ",Object(l.jsx)("span",{className:"code-block",children:"^1=>^1*"})," and ",Object(l.jsx)("span",{className:"code-block",children:"^0=>^0*"}),". Let's assume our input is the palindrome ",Object(l.jsx)("span",{className:"code-block",children:"^10101$"}),". After one round, the output will be ",Object(l.jsx)("span",{className:"code-block",children:"^1*0101$"}),", indicating that we're working with the first bit."]}),Object(l.jsxs)("div",{className:"space",children:["Next, we use the four rules ",Object(l.jsx)("span",{className:"code-block",children:"1*1=>11*, 1*0=>01, 0*1=>10*, 0*0=>00*"}),' to "walk" the marked bit all the way to the end. Here\'s what the string would be after each round:']}),Object(l.jsxs)("div",{className:"space box",children:["Round 1: \xa0 ^1*0101$",Object(l.jsx)("br",{}),"Round 2: \xa0 ^01*101$",Object(l.jsx)("br",{}),"Round 3: \xa0 ^011*01$",Object(l.jsx)("br",{}),"Round 4: \xa0 ^0101*1$",Object(l.jsx)("br",{})]}),Object(l.jsxs)("div",{className:"space",children:["Now that the marked bit is at the end, we can use the rules ",Object(l.jsx)("span",{className:"code-block",children:"1*1$=>$, 0*0$=>$, 1*0$=>x, 0*1$=>x"})," to compare the two bits. If the two bits are the same, they get subsumed into the ",Object(l.jsx)("span",{className:"code-block",children:"$"}),", and if they're different I mark it with an ",Object(l.jsx)("span",{className:"code-block",children:"x"}),". Note that once an ",Object(l.jsx)("span",{className:"code-block",children:"x"})," has been marked, we need not check any further and can fold the whole string down to a character. If the bits were indeed the same, we continue."]}),Object(l.jsxs)("div",{className:"space",children:["Finally, the whole process repeats and we'd end up with either ",Object(l.jsx)("span",{className:"code-block",children:"^x, ^$, ^1$"}),", or ",Object(l.jsx)("span",{className:"code-block",children:"^0$"})," (the latter three being palindromes). We add the rules ",Object(l.jsx)("span",{className:"code-block",children:"1x=>x, 0x=>x, ^x=>not_palindrome, ^$=>palindrome, ^1$=>palindrome, ^0$=>palindrome"}),", and we're done."]}),Object(l.jsxs)("div",{className:"space",children:[Object(l.jsx)("b",{children:"Level 6."})," To pass the final level, we must implement a binary adder. Let's assume that our input is ",Object(l.jsx)("span",{className:"code-block",children:"^101+111=1100$"})," (and the expected output is ",Object(l.jsx)("span",{className:"code-block",children:"'Correct'"}),'). We can use the same trick we used in level 5 and "walk" the LSB of the first number (the first character before the ',Object(l.jsx)("span",{className:"code-block",children:"+"}),") all the way to the LSB of the second number (the first character before the ",Object(l.jsx)("span",{className:"code-block",children:"="}),") and do a comparison."]}),Object(l.jsxs)("div",{className:"space",children:['Except, when adding two bits, we need to consider the carry bit. To do this, we can again borrow an idea from the previous level by creating a "marker" and using it as a state variable to store the carry bit. I chose the character ',Object(l.jsx)("span",{className:"code-block",children:"'c'"})," (to denote that the carry flag was set) and the string ",Object(l.jsx)("span",{className:"code-block",children:"'nc'"})," (to denote that the carry flag was not set) and placed them just after the ",Object(l.jsx)("span",{className:"code-block",children:"+"}),". These 4 setup rules were ",Object(l.jsx)("span",{className:"code-block",children:"1==>1nc=, 0==>0nc=, 1+=>1*+, 0+=>0*+"}),"."]}),Object(l.jsx)("div",{className:"space box",children:"Round 1: \xa0 ^101*+111nc=1100$"}),Object(l.jsxs)("div",{className:"space",children:['Next, we can "walk" the LSB of the first number to the LSB of the second number using the rules ',Object(l.jsx)("span",{className:"code-block",children:"1*+=>+1*, =>0*+=>+0*, 1*1=>11*, 1*0=>01*, 0*0=>00*, 0*1=>10*"}),"."]}),Object(l.jsxs)("div",{className:"space box",children:["Round 2: \xa0 ^10+1*111nc=1100$",Object(l.jsx)("br",{}),"Round 3: \xa0 ^10+11*11nc=1100$",Object(l.jsx)("br",{}),"Round 4: \xa0 ^10+111*1nc=1100$",Object(l.jsx)("br",{})]}),Object(l.jsxs)("div",{className:"space",children:["Now that the LSBs are together, we can finally do the addition. Note that because of the carry bit, there are 8 possible outcomes: ",Object(l.jsx)("span",{className:"code-block",children:"0*0nc==>nc=0*, 0*0c==>nc=1*, 0*1nc==>nc=1*, 0*1c==>c=0*, 1*0nc==>nc=1*, 1*0c==>c=0*, 1*1nc==>c=0*, 1*1c==>c=1*"}),"."]}),Object(l.jsxs)("div",{className:"space box",children:["Round 5: \xa0 ^10+11c=0*1100$",Object(l.jsx)("br",{}),"Round 6: \xa0 ^10+11c=10*100$",Object(l.jsx)("br",{}),"Round 7: \xa0 ^10+11c=110*00$",Object(l.jsx)("br",{}),"Round 8: \xa0 ^10+11c=1100*0$",Object(l.jsx)("br",{})]}),Object(l.jsxs)("div",{className:"space",children:["Finally, now that the aggregated bit is at the end, we can compare it with the LSB of the result. If they match, it gets subsumed into a $, and if not, we mark it with an ",Object(l.jsx)("span",{className:"code-block",children:"x"}),": ",Object(l.jsx)("span",{className:"code-block",children:"0*0$=>$, 1*1$=>$, 0*1$=>x, 1*0$=>x"}),"."]}),Object(l.jsx)("div",{className:"space box",children:"Round 9: \xa0 ^10+11c=110$"}),Object(l.jsxs)("div",{className:"space",children:["The cycle then repeats until we reach the edge cases. There are two possible scenarios: Either a calculation went wrong somewhere along the line and we fold the string down using ",Object(l.jsx)("span",{className:"code-block",children:"ncx=>x, cx=>x, ^x=>x, +x=>x, =x=>x, 1x=>x, 0x=>x, x=>incorrect"}),", or everything worked out fine and we would end up with ",Object(l.jsx)("span",{className:"code-block",children:"^0+0c=1$=>correct, ^0+0nc=0$=>correct"}),". One more thing to note is that the numbers maybe padded with upto 3 zeroes, so we need to pad all inputs with zeroes whenever required: ",Object(l.jsx)("span",{className:"code-block",children:"+c=>+0c, +nc=>+0nc, ^+=>^0+, =$=>=0$"}),". Here's the full script:"]}),Object(l.jsx)(p,{children:"from pwn import remote, process\n\ndebug = True\n\nif not debug:\n    p1 = remote('mc.ax', 31996)\nelse:\n    p1 = process(['python3.8', 'chall.py'])\n\ndef send_subs(subs):\n    for _ in range(3):\n        p1.recvline()\n\n    p1.sendline('y')\n\n    for _ in range(33):\n        p1.recvline()\n    \n    if len(subs) > 1:\n        for sub in subs[:-1]:\n            p1.sendline(sub[0] + '=>' + sub[1])\n            p1.sendline('y')\n\n    p1.sendline(subs[-1][0] + '=>' + subs[-1][1])\n    p1.sendline('n')\n\nfor _ in range(11):\n    p1.recvline()\n\nprint('Level 1')\nsend_subs([('initial', 'target')])\n\nprint('Level 2')\nsend_subs([('ginkoid', 'ginky'), ('hello', 'goodbye')])\n\nprint('Level 3')\nsend_subs([('aa', 'a')])\n\nprint('Level 4')\nsend_subs([('ggg', 'gg'), ('gg', 'ginkoid')])\n\nprint('Level 5')\nsend_subs([\n  # Edge cases\n  ('1x', 'x'), ('0x', 'x'), ('^x', 'not_palindrome'),\n  ('^$', 'palindrome'), ('^1$', 'palindrome'), ('^0$', 'palindrome'),\n\n  # Checks\n  ('1*1$', '$'), ('0*0$', '$'), ('1*0$', 'x'), ('0*1$', 'x'),\n\n  # Walk\n  ('1*1', '11*'), ('1*0', '01*'), ('0*1', '10*'), ('0*0', '00*'),\n\n  # Setup\n  ('^1', '^1*'), ('^0', '^0*')\n])\n\nprint('Level 6')\nsend_subs([\n  # Edge cases\n  ('^0+0c=1$', 'correct'), ('^0+0nc=0$', 'correct'),\n  ('ncx', 'x'), ('cx', 'x'), ('^x', 'x'), ('+x', 'x'),\n  ('=x', 'x'), ('1x', 'x'), ('0x', 'x'), ('x', 'incorrect'),\n\n  # Padding\n  ('+c', '+0c'), ('+nc', '+0nc'), ('^+', '^0+'), ('=$', '=0$'),\n\n  # Checks\n  ('0*0$', '$'), ('1*1$', '$'), ('0*1$', 'x'), ('1*0$', 'x'),\n\n  # Additions\n  ('0*0nc=', 'nc=0*'), ('0*0c=', 'nc=1*'), ('0*1nc=', 'nc=1*'), ('0*1c=', 'c=0*'),\n  ('1*0nc=', 'nc=1*'), ('1*0c=', 'c=0*'), ('1*1nc=', 'c=0*'), ('1*1c=', 'c=1*'),\n\n  # Walk\n  ('1*+', '+1*'), ('0*+', '+0*'), ('1*1', '11*'), ('1*0', '01*'),\n  ('0*0', '00*'), ('0*1', '10*'),\n  \n  # Setup\n  ('1=', '1nc='), ('0=', '0nc='), ('1+', '1*+'), ('0+', '0*+')\n])\n\nfor _ in range(5):\n    print(p1.recvline())"})]})})}}]),n}(a.Component),H=(n(404),a.Component,function(A){Object(s.a)(n,A);var e=Object(r.a)(n);function n(){return Object(t.a)(this,n),e.apply(this,arguments)}return Object(i.a)(n,[{key:"render",value:function(){return Object(l.jsx)("div",{className:"home-list-item",children:Object(l.jsx)("li",{children:Object(l.jsx)(g.b,{to:this.props.route,children:this.props.title})})})}}]),n}(a.Component)),z=function(A){Object(s.a)(n,A);var e=Object(r.a)(n);function n(){return Object(t.a)(this,n),e.apply(this,arguments)}return Object(i.a)(n,[{key:"render",value:function(){return Object(l.jsx)("div",{className:"home",children:Object(l.jsx)("ul",{className:"home-list",children:Z.slice(1).map((function(A){A.Page;var e=A.route,n=A.title;return Object(l.jsx)(H,{route:e,title:n})}))})})}}]),n}(a.Component),J=(n(411),function(A){return function(e){return Object(l.jsx)("div",{className:"page-wrapper",onClick:e.onClick,children:Object(l.jsx)(A,{})})}}),Z=[{Page:J(z),route:"/",title:"Home"},{Page:J(y),route:"/pickled_onions_redpwn_2021",title:"Pickled Onions"},{Page:J(X),route:"/the_substitution_game_redpwn_2021",title:"The Substitution Game"},{Page:J(D),route:"/lunch_with_the_cia_hsctf_2021",title:"Lunch With The CIA"},{Page:J(N),route:"/babysign_thc_2021",title:"BabySign"}],Y=function(A){var e="/"+A.target.href.split("/").slice(-1)[0].split("#")[0];return Object.entries(Z).filter((function(A){var n=Object(c.a)(A,2),t=(n[0],n[1]);return e==t.route})).map((function(A){var e=Object(c.a)(A,2);e[0];return e[1].title}))},T=function(A){Object(s.a)(n,A);var e=Object(r.a)(n);function n(A){var i;return Object(t.a)(this,n),(i=e.call(this,A)).state={title:"Home",menuShown:!1},i}return Object(i.a)(n,[{key:"hideMenu",value:function(){this.setState({menuShown:!1})}},{key:"showMenu",value:function(){this.setState({menuShown:!0})}},{key:"toggleMenu",value:function(){this.setState({menuShown:!this.state.menuShown})}},{key:"setTitle",value:function(A){this.setState({title:A})}},{key:"navigate",value:function(A){this.hideMenu()}},{key:"render",value:function(){var A=this;return Object(l.jsx)(g.a,{children:Object(l.jsxs)("div",{className:"wrapper",children:[Object(l.jsx)(Q,{menuShown:this.state.menuShown,title:this.state.title,onClick:this.toggleMenu.bind(this)}),Object(l.jsxs)("div",{onClick:this.hideMenu.bind(this),className:"main-wrapper"+(this.state.menuShown?" overlay":""),children:[Object(l.jsx)("nav",{className:this.state.menuShown?"":"nav-hide",children:Object(l.jsx)("ul",{children:Z.filter((function(A){A.Page,A.route;return"Home"!==A.title})).map((function(e){e.Page;var n=e.route,t=e.title;return Object(l.jsx)("li",{className:A.state.menuShown?"":"hide",children:Object(l.jsx)(g.b,{onClick:A.navigate.bind(A,t),to:n,children:t})})}))})}),Object(l.jsx)(h.c,{children:Z.map((function(e,n){var t=e.Page,i=e.route;return Object(l.jsx)(h.a,{path:i,exact:!0,children:Object(l.jsx)(t,{overlay:A.state.menuShown,onClick:A.hideMenu.bind(A)})})}))})]})]})})}}]),n}(a.Component);o.a.render(Object(l.jsx)(T,{}),document.getElementById("root"))}},[[412,1,2]]]);
//# sourceMappingURL=main.346578b0.chunk.js.map